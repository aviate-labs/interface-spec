= Public specification of the DFINITY Computer
Joachim Breitner <joachim@dfinity.org>
:toc2:
:toclevels: 3
:stem: latexmath
:source-highlighter: pygments
:icons: font

== Preamble

This document is work in progress, initially authored by mailto:joachim@dfinity.org[Joachim]. The goal is to have a document that is authoritative, and provides a place and a language to discuss public features of DFINITY in a hopefully concrete way. It could also be a document that we can publish to users of DFINITY.

Because of its focus on the externally visible behavior of DFINITY, it will also help uncover abstraction leaks. Because it aims to describe the full behavior, it helps to show which designs are unexpectedly complicated.

=== Contact

It will be everyone’s shared responsibility to keep this document accurate, but the editor’s responsibility to keep it focused and consistent. If you have additions or corrections, either talk to Joachim in whatever form you prefer, or propose changes to the document directly (but be prepared for editorial rewrites of your text).

=== Status

We are figuring our the right structure and scope of the document itself, using just core functionality of DFINITY as the working example.

The basic functionality of installing a canister and canister method calls, should already be rather precise. Beyond that, there are open questions and missing bits (see below). I need your help to correct these, and either adjust the content to reality, or at least to our actual plans.

Please also skim the https://github.com/dfinity-lab/dfinity/pulls?q=is%3Apr+is%3Aopen+%22Public+Spec%22+in%3Atitle[list of open PRs] against this document, to get an overview of ongoing discussions.

=== Open questions and missing bits

As we are fleshing out this document, we get comments that we cannot immediately resolve. In order to not drop them, and make it clear to readers which parts are not done yet, we are briefly collecting them here.  (Items marked [MM] are things Mack has committed to take a cut at clarifying functional requirements for by August 19.)

* Canister IDs: Really just 64 bit numbers, and which textual format? [MM]
* User IDs: Same question. Do these share the same namespace?
* Missing: Methods without responses/fire-and-forget calls
* To be changed: The System API for calls should be replaced with a more general API that allows canisters to submit API messages.
* Missing: Canisters need to _declare_ which calls are query calls (e.g. `msg_update <name>` vs. `msg_query <name>`)
* Missing: Specifying when responses are deleted.
* Missing: Ingress messages signature and public key scheme
* Missing: Canister upgrades.
* Missing: Payment and accounts [MM]
* Missing: Gas accounting [MM or Dom]
* Missing: Subnet ids (e.g. modeling multiple HTTP endpoints, multiple accounts, locality requirements of requests) [MM]
* Missing: Time (idea: separate per-canister time, nondeterministic time step transition) [MM]
* Missing: Canister likely need some kind of file store (for IDL specs, static assets, incremental canister module uploads)
* Missing: Storing and retrieving static data (e.g. the Wasm module itself, its IDL spec, HTML assets)
* Missing: Reads may specify a specific (future or past) state
* Missing (optional): References in call arguments and responses? Which references are supported? Can we have `funcrefs`?
* Missing (optional): Certified variables (globals pointing to memory? specially marked read-only methods?)
* Missing (optional): Programmatic canister creation
* Missing (optional): Incremental canister upload for big canister modules.

== Introduction

Welcome to the DFINITY Internet Computer! We speak of “the” DFINITY Internet Computer, because although under the hood, a large number of physical computers are working together in non-trivial ways, in the end we have the appearance of a single, shared, secure and world-wide accessible computer. Much, if not all, of the advanced and complex machinery is hidden from those that use the DFINITY computer to run their applications and those who use these applications.

=== Scope of this document

This documents describes this external view of the DFINITY Internet Computer:
Which interfaces it provides to application developers and users, and what will happen when you use these interfaces.

WARNING: While this document describes the public interface and behavior of the DFINITY Internet Computer, it is not the primary end-user documentation. DFINITY provides further tools, such as the ActorScript programming language, the IDL tooling and the SDK tools, to make programming and using the DFINITY Internet Computer even more convenient. As an end-user, you might want to start with #TODO#.

If you think of the DFINITY Internet Computer as a distributed execution engine that _provides_ a WebAssembly-based application hosting service, then this document describes exclusively the latter aspect of it. So to the extent possible, this document will _not_ talk about blockchain, consensus protocols, nodes, subnets and orthogonal persistence. If you want to learn more about the exciting inner workings of DFINITY, please consult the link:../index{outfilesuffix}[Component Interface Specifications].

This document tries to be implementation agnostic: If we decide to re-do the implementation of the DFINITY Internet Computer from scratch at some point in the future, then this document would (ideally) still be valid as is.

This implies that this document does not speak of the interface of the DFINITY Internet Computer towards its engineers and administrators, as topics like node update, monitoring, logging are inherently tied to the actual _implementation_ and its architecture.


=== Overview of the Internet Computer

If you want to use the DFINITY Internet Computer as an application developer, you first create a _canister module_ that contains the WebAssembly code and configuration for your application, and deploy it using the <<http-interface,public HTTP interface>>. You can create canisters using the ActorScript language and the DFINITY SDK (#TODO: Link to SDK docs#), which is more convenient. If you want to use your own tooling, however, then this document describes <<canister-module-format,how a canister module looks like>> and how the <<system-api,WebAssembly code can interact with the system>>.

Once your application is running on DFINITY, it is a _canister_, and users can interact with it. They can use the <<http-interface,public HTTP interface>> to send _ingress method calls_ to the canister, which are eventually delivered to the canister, according to the <<system-api,System API>>.

The user can also use the HTTP interface to issue read-only queries, which are faster, but cannot change the state of the canister.



.A typical use of the DFINITY computer. (This is a simplified view; some of the arrows represent multiple interaction steps or polling.)
[plantuml]
....
actor Developer
actor User
participant DFINITY
participant "Canister 1" as Can1
Developer -> DFINITY : /submit create canister
create Can1
DFINITY -> Can1 : create
Developer <-- DFINITY : canister-id=1
Developer -> DFINITY : /submit install module
DFINITY -> Can1 : initialize
|||
User -> DFINITY : /submit call “hello”
DFINITY -> Can1 : hello
return "Hello world!"
User <-- DFINITY : "Hello World!"
....

Section “<<interfaces>>” describes these interfaces, together with a brief description of what they do. Afterwards, you will find a <<public-spec,more formal description>> of the DFINITY Internet Computer that describes its abstract behavior with high precision.


== About calls and messages


=== Nomenclature

To get some consistency in this document, we try to use the following terms around method calls and messaging:

The public entry points of canisters are called _methods_. Methods can be _called_, from _caller_ to _callee_, and will eventually incur a _response_ which is either a _reply_ or a _reject_. A method may have _parameters_, which are provided with concrete _arguments_ in a method call. Calls can be _update calls_ (state mutation is preserved) or _query calls_ (state mutation is discarded).

These are implemented using _messages_ from a _sender_ to a _receiver_, messages do not have a response.

WebAssembly  _functions_ are exported by the WebAssembly module or provided by the System API. These are _invoked_ and can either _trap_ or _return_, possibly with a return value. Functions, too, have parameters and take arguments.

=== Ordering guarantees

In order to allow for a distributed implementation of the DFINITY Internet Computer, the order in which the various messages between canisters are delivered and executed is not fully specified.

The  guarantee we do give is that function calls between two canisters are executed in order, so that a canister that requires in-order execution need not wait for the response from an earlier message to a canister before sending a later message to that same canister.

More precisely:

 * Method calls between any _two_ canisters are delivered in order, as if they
   were communicating over a single simple FIFO queue.
 * If a WebAssembly function, within a single invocation, makes multiple calls
   to the same canister, they are queued in the order of invocations to `msg.call`.
 * Responses (including replies with `msg.reply`, explicit rejects with `msg.reject` and system-generated error responses) do _not_ have any ordering guarantee relative to each other or to method calls.
 * There is no particular order guarantee for ingress messages submitted via
   the HTTP interface.

WARNING: There is a currently a discrepancy between the
link:../functional{outfilesuffix}[Functional Spec] (calling for all _messages_ to be ordered) and a later design document calling for all _calls_ to be ordered; this may need resolving.

[#interfaces]
== Public Interfaces

[#http-interface]
=== HTTPS API Interface

You can interact with the DFINITY Computer using an RPC interface, called the _HTTPS API_, which exposes a small number of endpoints that take structured requests.

==== Submitting requests vs. reading

Certain interactions change the state of the DFINITY Internet Computer. By the very nature of a distributed implementation of this interface, they cannot be acted upon immediately, but only with a delay. Moreover, the actual node that the client talks to may not be honest or, for other reasons, may fail to get the request on the way. This implies the following high-level workflow:

1. A client submits a message via the `submit` RPC endpoint. No useful information is returned from the node (as it would not be trustworthy anyways).
2. For a certain amount of time, the system behaves as if it does not know about the message.
3. At some point, the system agrees to accept the message. From now on, the client can ask any node (of the right subnet) about the status of the message. The system is now processing the message.
4. At some later point, the request is acted upon. For some messages this is atomically, for others this involves multiple internal steps.
5. Eventually, a response (indicating success or failure, and possibly carrying data) will be produced, and can be retrieved from any node for a certain amount of time.
6. At the end, the system forgets about the request and its response.

When asking the system about the state or response of a request, the client uses a message id.

Other interactions do not change the state of the system, but only _read_ from it. These may either be untrustworthy, in the sense that a malicious node can make up stuff (e.g. query calls to canisters), or certified, in the sense that the node can prove to the client that this is indeed the system's view of things (e.g. reading message statuses, reading account balances). All these reads go through the `read` RPC endpoint.

We use the term _message_ both for the asynchronous messages that passed to `submit`, as well as for the parameters of a _read_, so that common operations like signing can be done in the same way.


==== Synchronicity across nodes

This documents describes the DFINITY Internet Computer as having a single global state that can be modified and queried. In reality, it consists of many nodes, which may not be perfectly in sync.

As long as you talk to one (honest) node only, the observed behavior is nicely sequential. If you issue an update (i.e. state-mutating) call to a canister (e.g. bump a counter), and node A indicates that the call has been executed, and you then issue a query call to node A, then A's response is guaranteed to include the effect of the update call (and you will receive the updated counter value).

If you then (very quickly) issue a read request to node B, it may be that B responds to your read query based on the old state of the canister (and you might receive the old counter value).

A related problem is that some reads are not certified, and nodes may be dishonest in their response. In that case, the client might want to get more assurance by querying multiple nodes and comparing the result, which is easier if the all queries run against the same state.

Both problems can be solved if read requests can specify the desired state to query, either at-least-this-state (to solve the first problem) or an exactly-this-future-state (to solve the second). This requires some way of identifying states (abstract state counters, timestamps, block heights).

NOTE: Even without this feature, applications can work around these problems. For the first problem, the query result could be such that the client can tell if the query has been received or not. For the second problem, if replies are monotonic in some sense the client can get assurance in their intersection (e.g. if the query returns a list of events that grows over time, then even if different nodes return different lists, the client can get assurance in those events returned by many nodes).

[#api-endpoints]
==== Endpoints

This document does not yet explain how to find the location and port of a running DFINITY node, nor how to find out which node(s) to talk to for a given canister.

The following API endpoints are provided:
....
/api/v1/submit
/api/v1/read
....

NOTE: Should we add features that _change the state_ but are node-specific (e.g., “restart”), then these would go through a new endpoint like `/api/v1/command`.

For all endpoints, the client performs a POST HTTP request with `Content-type: application/cbor`. The body is an CBOR value containing the message resp. read request object.

The `/api/v1/submit` endpoint returns, upon successful submission, a (code 200) HTTP response without a body; the user uses a separate `message-status` read (see <<api-status>>) to determine the response. In contrast, a successful read via `/api/v1/read` returns a response (a CBOR value) as the body of the (code 200) HTTP response. In both cases case, the usual HTTP errors (e.g. 500) may occur.

NOTE: For some reads (but not all), the node will be able to _prove_ that the overall system agrees on the particular value (e.g. fetching the response from an update call). For which reads, and how this can happen, still needs to be specified.

NOTE: Some or all calls to `/api/v1/read` might have to be paid for using a micro payment scheme (e.g. state-channel). This would be specified here, as a mechanism that is abstract in the content of the read request.

[#api-cbor]
==== CBOR encoding of messages and responses

Messages and responses are specified here as records with named fields and using suggestive human readable syntax. The actual format in body of the HTTP request or response, however, is https://en.wikipedia.org/wiki/CBOR[CBOR].

Concretely, it consists of a data item with major type 6 (“Semantic tag”) and tag value `55799` (see https://tools.ietf.org/html/rfc7049#section-2.4.5[Self-Describe CBOR]),
followed by a data item with major type 5 (“Map of pairs of data items”), followed by the the fields of the record. The keys are encoded with major type 3 (“Text string”). The values are one of these major types (with more to be added as needed):

* Strings: Major type 3 (“Text string”).
* Blobs: Major type 2 (“Byte string”)
* Integer numbers: Major type 0 or 1 (“Unsigned/signed integer”) if small enough to fit that type, else the https://tools.ietf.org/html/rfc7049#section-2.4.2[Bignum] format is used.
* Nested records: Major type 5 followed by string keys.

As advised by https://tools.ietf.org/html/rfc7049#section-3[section “Creating CBOR-Based Protocols” of the CBOR spec], we clarify that:

* Floating-point numbers may not be used to encode integers.
* Duplicate keys are prohibited in CBOR maps.


[#api-common-fields]
==== Common fields of messages

While different types of messages have additional fields (listed below as “Message fields”), some fields are common among all messages:

* `message_type` (string): One of the message types specified below.

Furthermore, some fields are common among all _asynchronous_ messages, i.e. those submitted to `/api/v1/submit`:

* `expiry`: time(?) until the message must be executed or dropped #TODO: details#
* `nonce` (optional): Arbitrary client-provided string, typically randomly generated. This can be used by the client to create distinct messages with otherwise identical fields.
* `sender`: The id of the user issuing this message.
* `sender_sig`: Signature authenticating the `sender`. This is a placeholder field to indicate that these messages are signed, but the precise signature scheme is not yet defined. Also see <<abstract-signature>>.

NOTE: Information related to gas payments in a user-pays model would also be specified here, as a general mechanism for various message types.

NOTE: There is no `message_id` field. Instead, there is a procedure to calculate the `message_id` based on the content of the message fields, see <<api-message-id>>.


[#api-register-user]
==== User registration

Users are registered via ingress messages. This will allocate a fresh user id, associate the provided public key with that user, and (not yet specified here) create an empty payment account.

Endpoint:: `/api/v1/submit`
Message type:: `create_user`
Message fields::
* `public_key`: The public key that may be used to authenticate the user.
Reply fields::
* `user_id`: The user id of the just registered user.

NOTE: Precise format and meaning of the public key field will be specified together with message signatures.

NOTE: Lots of user management messages are still missing, of course, such as adding additional keys, removing keys etc.

[#api-create-canister]
==== Canister registration

Before deploying a canister, the administrator of the canister first has to register  it with the system, to get a canister id (with an empty canister behind it), and then separately install the code.

A canister has a list of _admin users_; initially, the user who has registered the canister is the only admin user.

Endpoint:: `/api/v1/submit`
Message type:: `create_canister`
Message fields::
* None
Reply fields::
* `canister_id`: The canister id of the just created canister.

Until code is installed, the canister behaves like one with no public methods.

NOTE: This message may later contain specifications of particular features needed from the hosting subnet

[#api-install-code]
==== Canister code installation

After an empty canister has been created via <<api-create-canister>>, the admin can install the first code:

Endpoint:: `/api/v1/submit`
Message type:: `install_code`
Message fields::
* `canister_id`: The id of the canister to install code for.
* `module` (blob): A <<canister-module-format,canister module>>
* `arg` (optional, blob): Initialization arguments
Reply fields::
* None

Only a user who is an _admin user_ for the canister can install code.

This will instantiate the canister module and invoke its `dfn_init` system method, as explained in Section “<<system-api-init>>“, passing the `arg`, if given, as the method argument.

If the canister does not have a `dfn_init` system method, then it is an error to pass an `arg`. If no `arg` is given but a `dfn_init` system method is present, an argument of length 0 is assumed.

This is atomic: If the response to this message is a `reject`, then this message had no effect. It is an error to invoke `install_code` on a canister again after a previous code installation has succeeded; canister upgrades are handled separately. (This may be relaxed later, in particular if we switch to a non-serializing approach to persistent storage.)

NOTE: This assumes that a canister module fits into a single message. If this assumption turns out to be false, we will provide a more elaborate multi-step interface for code installation. But even then, this simple, atomic way is worth keeping (less error conditions), so we are forward-compatible.

NOTE: Upgrading (i.e. deploying code while preserving state) is a separate message type, not yet described here.

NOTE: Undecided: Should this message also be used to re-install  canister code (i.e. replace the code _without_ preserving the state)? If so, should that intention be made explicit via some field `replace: true` or such?

[#api-update]
==== Canister update call

Endpoint:: `/api/v1/submit`
Message type:: `call`
Message fields::
* `canister_id`: The id of the canister to call.
* `method_name`: Name of the canister method to call
* `arg` (blob): Argument to pass to the canister method
Reply fields::
* `arg` (blob): The blob representing the data replied by the canister.

This message type can _also_ be used to call a query method. A user may choose to go this way, instead of via the likely faster and cheaper <<api-query>> below, if they want to get a _certified_ response.

NOTE: Other arguments besides data (e.g. payments) will be represented in further fields next to `arg`.

[#api-status]
==== Message status

Endpoint:: `/api/v1/read`
Message type:: `message-status`
Message fields::
* `message_id` (blob): The message id to check the status for.
Response fields::
* `status`: one of `unknown`, `accepted`, `replied` or `rejected`
* `reply`: If the status is `replied`, then this member contains the message-type specific reply object (see the specification for the individual message types for which fields exist).
* `reject_code` (natural number): If the status is `rejected`, then this member contains the reject code (see <<reject-codes>>).
* `reject_message` (string): If the status is `rejected`, then this member contains a textual diagnostic message.

The status `accepted` is used for messages that have successfully entered the system, known to all nodes, and that are guaranteed to be acted upon eventually.

WARNING: Immediately after submitting a message, this may fail (e.g. return with `unknown`) even though the system is still working on accepting the message.

NOTE: Request responses will not actually be kept around indefinitely, and eventually the status will revert to `unknown`. This will happen no sooner than the message’s expiry time, so that replay attacks are prevented. The precise policy is not yet defined.


[#api-query]
==== Canister query call

Canister methods that do not change the canister state in a meaningful way can be executed more efficiently. This method provides that ability, and returns the canister’s response directly within the HTTP response.

Endpoint:: `/api/v1/read`
Message type:: `query`
Message fields::
* `canister_id`: The id of the canister to query.
* `method_name`: Name of the canister query method to call
* `arg` (blob): Argument to pass to the canister method
Response fields::
* `status`: one of `replied` or `rejected`
* `reply`: If the status is `replied`, then this member contains the call reply, just as specified in <<api-update>>.
* `reject_code` (natural number): If the status is `rejected`, then this member contains the reject code (see <<reject-codes>>).
* `reject_message` (string): If the status is `rejected`, then this member contains a textual diagnostic message.

[#reject-codes]
=== Reject codes

An API message or inter-canister call that was accepted into the system will eventually result in either a _reply_ (indicating success, and carrying data) or a _reject_ (indicating an error of some sorts). A reject contains a _rejection code_ that classifies the error and a (hopefully) helpful error message string.

Rejection codes are member of the following enumeration:

* `SYS_FATAL`:  Fatal system error, retry unlikely to be useful.
* `SYS_TRANSIENT`: Transient system error, retry might be possible.
* `DESTINATION_INVALID`: Invalid destination (e.g. canister/account does not exist)
* `CANISTER_REJECT`: Explicit reject by the canister.
* `CANISTER_ERROR`: Canister error (e.g., trap, no response)

The symbolic names of this enumeration is used throughout this specification, but on all interfaces (HTTPS API, System API), they are represented as positive numbers, i.e.`SYS_FATAL=1`, `SYS_TRANSIENT=2` etc.

The error message is guaranteed to be a string, i.e. not arbitrary binary data.

[#api-message-id]
==== Message ids

When querying the status of a message (see <<api-status>>), the user identifies the message using a _message id_. The message id is a simple “object hash” of the message, as described here. The hash operation is always SHA-256.

1. For each field that is present in the message (i.e. omitted optional fields are indeed omitted), including `message_type`, hash the fields name (in ascii-encoding, without terminal `\0`) and the value (with the encoding specified below).
2. Sort these by the hash of the field name.
3. Concatenate these hashes, and hash the result

The resulting hash is the id of the message.

NOTE: The message id is independent of the representation of the message (JSON, CBOR, something else), and does not change if the specification adds further optional field to a message type.

The following encodings of field values are used

* String fields (`message_type`, `method_name`) are encoded in UTF-8, without a terminal `\0`.
* Binary blobs (`arg`, `nonce`, `module`) are hashed as they are.
* Canister IDs (`canister-id`, `callee`) are encoded as big endian 64 bit numbers.

[TIP]
Example calculation (where `H` denotes SHA-256 and `·` denotes blob concatenation):
[source,,options="nowrap"]
----
message_id_of({ message_type: "call", callee: 1234, method_name: "hello", arg: "DIDL\0\253*"})
 = H(concat (sort
   [ H("message_type") · H("call")
   , H("callee") · H("\0\0\0\0\0\0\4\210")
   , H("method_name") · H("hello")
   , H("arg") · H("DIDL\0\253*")
   ]))
 = H(concat (sort
   [ 9143ad758b2499f7f59b3e3cfb72b978d8fc13feda202c119ea9fcc2216bdf587edb360f06acaef2cc80dba16cf563f199d347db4443da04da0c8173e3f9e4ed
   , 92ca4c0ced628df1e7b9f336416ead190bd0348615b6f71a64b21d1b68d4e7e2cd35fe4661e0a51e858e99c71a3822c5388dac7734317b20627976c52084cc96
   , 293536232cf9231c86002f4ee293176a0179c002daa9fc24be9bb51acdd642b62cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
   , b25f03dedd69be07f356a06fe35c1b0ddc0de77dcd9066c4be0c6bbde14b23ffb05b171e1c7a6dc061b994a27cfc7c784946fcd5c115b972d95001e642aba99d
   ]))
 = H(concat
   [ 293536232cf9231c86002f4ee293176a0179c002daa9fc24be9bb51acdd642b62cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
   , 9143ad758b2499f7f59b3e3cfb72b978d8fc13feda202c119ea9fcc2216bdf587edb360f06acaef2cc80dba16cf563f199d347db4443da04da0c8173e3f9e4ed
   , 92ca4c0ced628df1e7b9f336416ead190bd0348615b6f71a64b21d1b68d4e7e2cd35fe4661e0a51e858e99c71a3822c5388dac7734317b20627976c52084cc96
   , b25f03dedd69be07f356a06fe35c1b0ddc0de77dcd9066c4be0c6bbde14b23ffb05b171e1c7a6dc061b994a27cfc7c784946fcd5c115b972d95001e642aba99d
   ])
 = b2353e5f132031736451832d5a0c90a4360a0425889fcb55df7887002f9a7312
----

[#canister-module-format]
=== Canister module format

A canister module is simply a https://webassembly.github.io/spec/core/index.html[WebAssembly module] in binary format (typically `.wasm`).

WARNING: This is a scaffolding spec, close to the current implementation. It will need refinement for features like initialization parameters, dynamically linked libraries. We probably want to go for some zip-file-with-metadata approach.


[#system-api]
=== Canister interface (System API)

The System API is the interface between the running canister and the DFINITY Internet Computer. It allows the WebAssembly module of a canister to expose functionality to the users (method entry points) and the system (e.g. initialization), and exposes system functionality to the canister (e.g. calling other canisters). Because WebAssembly is rather low-level, it also explains how to express higher level concepts (e.g. binary blobs).

[#system-api-module]
==== WebAssembly module requirements

In order for a WebAssembly module to be usable as the code for the canister, it needs to conform to the following requirements:

* If it imports a memory, it must import it from `env.memory`. In the following, “the Wasm memory” refers to this memory.
* If it imports a table, it must import it from `env.table`. In the following, “the Wasm table” refers to this table.
* It may only import functions listed below, at the type given below.
* It may have a `(start)` function. (Note that by construction, system calls that require a valid `api_nonce` will trap when called from `(start)`.)
* If it exports a function called `dfn_init`, it must have type `+(api_nonce : anyref) -> ()+`.
* If it exports any functions called `dfn_update <name>` for some `name`, it must have type `+(api_nonce : anyref) -> ()+`.
* If it exports any functions called `dfn_query <name>` for some `name`, it must have type `+(api_nonce : anyref) -> ()+`.
* It may not export both `dfn_update <name>` and `dfn_query <name>` with the same `name`.
* No floating point instructions are used in the module. (This may be allowed in the future.)

NOTE: This document assumes that WebAssembly host references can be used (e.g. `anyref`). Until this is so, every `anyref` is replaced with an `i64` that should be treated as opaque by the WebAssembly code.

==== Interpretation of numbers

WebAssembly number types (`i32`, `i64`) do not indicate if the numbers are to be interpreted as signed or unsigned. Unless noted otherwise, whenever the System API interprets them as numbers (e.g. memory offsets, array lengths), they are to be interpreted as unsigned.

==== The API nonce

A design goal of the System API is that the canister can restrict which parts of its code can use it. Therefore, all functions exported by the canister have an `api_nonce` parameter, and all invocations of system functions require such a parameter. Because this parameter is a WebAssembly host reference (type `anyref`), it cannot be forged.

[#system-api-messages]
==== Public methods

To define a public method of name `name`, a WebAssembly module exports a function with name `dfn_update <name>` or `dfn_query <name>` and type `+(api_nonce : anyref) -> ()+`. We call this the _method entry point_. The name of the exported function distinguishes update and query calls.

NOTE: The space in `dfn_update <name>` resp. `dfn_query <name>` is intentional.

The argument of the call (e.g. the content of the `arg` field in the <<api-update,API message to call a canister method>>) is copied into the canister on demand.
In the reply callback for a further <<system-api-send,method call>>, the argument refers to the response of that call; in reject callbacks, no argument is available. In other words, the lifetime of the argument data is a single WebAssembly function execution, not the whole method call tree.

* `+msg.arg_data_size : (api_nonce : anyref) -> i32+`
+
Size, in bytes, of the argument data.
+
This traps if there is no argument data is available (e.g. in a reply callback).

* `+msg.arg_data_copy : (api_nonce : anyref, dst : i32, length : i32, offset : i32) -> ()+`
+
Copies `length` bytes from `msg_arg[offset..offset+length]` to `memory[dst..dst+length]`, i.e., from the argument data into the Wasm memory.
+
This traps if `offset+length` is greater than the size of the argument data, or if `dst+length` exceeds the size of the Wasm memory, or if called from inside a reject callback (see below).

In a reject callback, no argument is available, but the reject code can be queried:

** `+msg.reject_code : (api_nonce : anyref) -> i32+`
+
Returns the reject code, if the current function is invoked as a reject callback.
+
It returns the special “no error” code `0` if the callback is _not_ invoked as a reject callback; this allows canisters to use a single entry point for both the reply and reject callback, if they choose to do so.
+
** `+msg.reject_msg_len : (api_nonce : anyref) -> i32+`
+
Returns the length of the reject message, in bytes. Traps if this is not invoked from a reject callback.
** `+msg.reject_msg_copy : (api_nonce : anyref, dst : i32, length : i32, offset : i32) -> ()+`
+
Copies `length` bytes from `reject_msg[offset..offset+length]` to `memory[dst..dst+length]`.
+
This traps if `offset+length` is greater than the size of the reject message, or if `dst+length` exceeds the size of the Wasm memory, or if not called from inside a reject callback.


Eventually, the canister will want to respond to the original call, either by replying (indicating success) or rejecting (signalling an error):

* `+msg.reply_data_append : (api_nonce : anyref, offset : i32, length : i32) -> ()+`
+
Copies the data referred to by `offset`/`length` out of the canister and appends it to the (initially empty) data reply.
+
NOTE: This can be invoked multiple times to build up the argument with data from various places on the Wasm heap. This way, the canister does not have to first copy all the pieces from various places into one location.
+
This system call traps if `offset+len` exceeds the size of the WebAssembly memory, or if the current call already has been responded to.

* `+msg.reply : (api_nonce : anyref) -> ()+`
+
Replies to the sender with the data assembled using `msg.reply_data_append`.
+
This function can be called at most once (a second call will trap), and must be called exactly once to indicate success.

* `+msg.reject : (api_nonce : anyref, offset : i32, length : i32) -> ()+`
+
Rejects the call. The data referred to by `offset`/`length` is used for the diagnostic message.
+
This system call traps if `offset+len` exceeds the size of the WebAssembly memory, or if the current call already has been responded to, or if the data referred to by `offset`/`length` is not valid UTF8.
+
Possible reply data assembled using `msg.reply_data_append` is discarded.

If the execution of the function traps for any reason, then all changes to the WebAssembly state, as well as the effect of any externally visible system call (like `msg.reply`, `msg.reject`, `call.invoke`), are discarded.

==== System methods

A canister may export a system method. In contrast to public methods, system methods can only be invoked by the system in special situations (initialization, upgrade). They are exported with an unmangled name (i.e. `dfn_init`, not `dfn_update init`), and it is allowed to have both a system method and public method of the same name. Otherwise, they use the same mechanism for parameter passing and API access.

[#system-api-init]
==== System method: dfn_init

If the canister exports a system method called `dfn_init`, then this is the first exported WebAssembly function invoked by the system. If an argument was passed along with the canister initialization (see <<api-install-code>>), it is passed as the argument, otherwise the argument is the empty blob.

The following system calls will trap when called during the execution of `dfn_init`: `msg.reply`, `msg.reply_data_append`, `msg.reject`, `call.create`.

The system assumes the canister to be fully instantiated if the `dfn_init` method entry point returns.  If the `dfn_init` method entry point traps, then canister installation has failed, and the canister is deleted.

[#system-api-canister-id]
==== Resolving canister ids

To future-proof the System API, references to canisters are represented as abstract WebAssembly references (`anyref`). We provide system functions to convert between the abstract references and their transparent public id, as used by the HTTP interface.

* `+canister.lookup : (api_nonce : anyref, canister_id : i64) -> (canister_ref : anyref)+`
* `+canister.id : (api_nonce : anyref, canister_ref : anyref) -> (canister_id : i64)+`

NOTE: These functions never trap, i.e. they always return a `canister_ref` (resp. a `canister_id`). In a future where not all canisters are publicly addressable by anyone, these conversion functions may become partial. Moreover, while they technically could, these functions do *not* check for the existence of the canister.

Furthermore, a canister can learn about its own canister id:

* `+canister.self : (api_nonce : anyref) -> (canister_ref : anyref)+`

[#system-api-send]
==== Sending messages

During an update call, a canister can do further calls to another canister. Performing a call is a multi-step process:

1. A canister/method-name pair is turned into an opaque `methref`.
2. A new call can be created from such a `methref`, represented by a `callref`.
3. A number of functions can add arguments (data, payments, etc.) to the call.
4. When everything is setup, the canister tells the system to perform the call.

The `methref` can be used multiple times, it just represents the canister/method-name pair.

The `callref` reference is only valid between `call.create` and `call.perform`, and only within a single WebAssembly function invocation; it cannot be stored or forwarded.

This design is extensible and forward compatible to new call destinations (e.g. new ways to obtain a `methref` besides just a public canister/method pair), new form of arguments (multiple payments, references) and other settings (gas, expiry times etc.)

* {blank}
+
  meth.public : (
    api_nonce    : anyref,
    callee       : anyref, // a canister reference
    name_offset  : i32,    // a pointer to and the length of the
    name_len     : i32,    //   destination’s unmangled method name
  ) -> ( methref : anyref )
+
Creates a new `methref` from a canister reference and the name of a public method. This function always succeeds. For example, no checking is done if the method actually exists.

* {blank}
+
  call.create : ( methref : anyref ) -> ( callref : anyref )
+
Begins the assembly of a new call, to the given method.
Returns the `callref` that can be filled further on.
+
This system call traps if it is calling during the handling of a <<api-query,query call>>.
* {blank}
+
  call.arg_data_append : (
    callref  : anyref  // the call to extend
    offset   : i32,    // a pointer to and the length of the
    len      : i32,    //   argument to pass to the method
  ) -> ()
+
Copies the data referred to by `offset`/`len` out of the canister and appends it to the (initially empty) data argument of the call.
+
NOTE: This can be invoked multiple times to build up the argument with data from various places on the Wasm heap. This way, the canister does not have to first copy all the pieces from various places into one location.
+
This system call traps if `offset+len` exceeds the size of the WebAssembly memory.
* {blank}
+
  call.on_reply : (
    callref : anyref  // the call to extend
    fun     : i32,    // funtab entry of type (api : anyref, env : i32) -> ()
    env     : i32,    // an environment to give back to fun
  ) -> ()
+
The system records the current function table entry at the index `fun`. Upon successful completion of the method call, the noted function is executed, and the response data can be queried using `msg.arg_data_size`/`msg.arg_data_copy`.
+
There must be exactly one invocation of `call.on_reply` for each `callref`. (Omitting `call.on_reply` may be allowed later to indicate that the sending canister does not care about receiving the reply.)
* {blank}
+
  call.on_reject : (
    callref : anyref  // the call to extend
    fun     : i32,    // funtab entry of type (api : anyref, env : i32) -> ()
    env     : i32,    // an environment to give back to fun
  ) -> ()
+
The system records the current function table entry at the index `fun`. If the method call fails, the noted function is executed.
+
There must be exactly one invocation of `call.on_reject` for each `callref`. (Omitting `call.on_reject` may be allowed later to indicate that the sending canister wants to ignore the response, or pass it on to its own reject handler.)

* {blank}
+
  call.perform : ( callref : anyref ) -> ()
+
Indicate that the call is ready to be performed. The system queues the call message to the given destination, but does not actually act on in until the current WebAssembly function returns without trapping.
+
After `call.perform`, the `callref` must not be used any more. Invoking any system function with that callref will trap.
+
If a call is created, but not performed by the time the WebAssembly function ends, it is discarded.

NOTE: The `call.`-prefixed system functions do not require an 'api_nonce', only the construction of the `methref` passed to `call.create` does.
This API design supports delegating the initialization of a given `callref` to less trusted code, without granting that code full access to the API via an `api_nonce`.

[#system-api-rand]
==== Randomness

With every update method call or response, the system provides fresh unpredictable entropy to the canister. This is cryptographically secure, i.e. neither the caller nor the callee could have had prior knowledge of the value.

* `+msg.entropy : (api_nonce : anyref) -> ( i64 )+`
+
Get the random entropy provided with this call. This function is constant during the execution of a single WebAssembly function.
+
During the execution of a query call, this function traps.

==== Debugging aids

During local development and execution on a local network, the canister needs a way to emit textual trace messages. On the “real” network, these do not do anything.

NOTE: This system call is intentionally not guarded by an `api_nonce`, so that one can do Printf-like debugging of code that otherwise is not allowed to issue system calls without having to refactor the code first.

* `+debug.print : (offset : i32, len : i32) -> ()+`
+
When executing in an environment that supports debugging, this copies out the data specified by `offset` and `len`, and logs, prints or stores it in an environment-appropriate way. The copied data may likely be a valid string in UTF8-encoding, but the environment should be prepared to handle binary data (e.g. by printing it in escaped form).
+
Semantically, this function is always a no-op, and never traps, even if the `offset+len` exceeds the size of the memory, or if this function is executed from `(start)`. If the environment cannot perform the print, it just skips it.

NOTE: We may at some point require modules deployed to the real network to not even import this function.

Similarly, the system allows the canister to effectively trap, but give some indication about why it trapped:

* `+debug.trap : (offset : i32, len : i32) -> ()+`
+
This function always traps.
+
The environment may copy out the data specified by `offset` and `len`, and log, print or store it in an environment-appropriate way, or include it in system-generated reject messages where appropriate. The copied data may likely be a valid string in UTF8-encoding, but the environment should be prepared to handle binary data (e.g. by printing it in escaped form).


[#public-spec]
== Abstract public behavior

The sections above describe the interface, i.e. outer edges of the DFINITY Internet Computer, but gives only intuitive and rather vague information about what these interfaces actually do.

This section aims to address that question with great precision, by describing the _abstract state_ of the whole DFINITY Internet Computer, and how this state can change in response to API function calls, or spontaneously (modeling asynchronous, distributed or non-deterministic execution).

The design of this abstract specification (e.g. how and where pending messages are stored) are _not_ to be understood to in any way prescribe a concrete implementation or software architecture. The goals here are formal precision and clarity, but not implementability, so this can lead to different ways of phrasing.

=== Notation

We specify the behavior of the system using pseudo-code.

The manipulated values are primitive values (numbers, text, binary blobs), aggregate values (lists, unordered lists a.k.a. bags, partial maps, records with fixed fields, named constructors) and functions.

We use an concatenation operator `·` with various types: to extend sets and maps, or to concatenate lists with lists or lists with elements.

The shape of values is described using a hand-wavy type system.  We use `Foo = Nat` to define type aliases; now `Foo` can be used instead of `Nat`. Often, the right-hand side is a more complex type here, e.g. a record, or multiple possible types separated by a vertical bar (`|`). Partial maps are written as  `Key ↦ Value` and the function type as `Argument -> Result`.

NOTE: All values are immutable! State change is specified by describing the new state, not by changing existing state.

Record fields are accessed using dot-notation (e.g. `S.request_id > 0`). To create a new record from an existing record `R` with some fields changed, the syntax `R where field = new_value` is used. This syntax can also be used to create new records with some deeply nested field changed: `R where some_map[key].field = new_value`.

In the state transitions, upper-case variables (`S`, `C`, `Req_id`) are free variables: The state transition may be followed for any possible value of these variables. `S` always refers to the state of the system before. A state transition often comes with a list of _conditions_, which may restrict the values of these free variables. The _state after_ is usually described using the record update syntax by starting with `S where`.

For example, the condition `S.messages = Older_messages · M · Younger_messages` says that `M` is some message in field `messages` of the record `S`, and that `Younger_messages` and `Older_messages` are the other messages in the system. If the “state after” specifies `S with messages = Older_messages · Younger_messages`, then the message `M` is removed from the state.

=== Abstract state

In this specification, we describe the DFINITY Internet Computer as a state machine. In particular, there is a single piece of data that describes the complete state of the system (called `S` below).

Of course, this is a huge simplification: The real DFINITY Internet Computer is distributed and has a multi-component architecture, and the state is spread over many different components, some physically separated. But this simplification allows us to have a concise description of the system, and to easily make global decisions (such as, “is there any pending message”), without having to specify the bookkeeping that allows such global decision.

==== Identifiers

Canisters and users are addressed simply by natural numbers; method names can be arbitrary pieces of text:
....
CanId = Nat
UserId = Nat
MethodName = Text
....

The system keeps `CanId` and `UserId` disjoint.


[#abstract-canisters]
==== Abstract canisters

The <<system-api,WebAssembly System API>> is relatively low-level, and some of its details (e.g. that the argument data is queried using separate calls, and that closures are represented by a function pointer and a number, that method names need to be mangled) would clutter this section. Therefore, we abstract over the WebAssembly details as follows:

* The state of a WebAssembly module (memory, tables, globals) is hidden behind an abstract `WasmState`.

* A canister module `CanisterModule` consists of an initial state, and a (pure) function that models function invocation. It either indicates that the canister function traps, or returns a new state together with a description of the invoked asynchronous System API calls.
+
....
WasmState = (abstract)

Entropy = NoEntropy | FreshEntropy i64
RejectCode = Nat
Response = Reply Blob | Reject (RejectCode, Text)
MethodCall = {
  callee : CanId;
  method_name: MethodName;
  arg: Blob;
  callback: Response -> UpdateFunc;
}

InitFunc = (Entropy, CanId, Blob) -> Trap | Return WasmState
UpdateFunc = (Entropy, CanId, WasmState) -> Trap | Return {
  new_state : WasmState;
  new_calls : List MethodCall;
  response : NoResponse | Response;
}
QueryFunc = (CanId, WasmState) -> Trap | Return Response


CanisterModule = {
  init : InitFunc
  update_methods : MethodName ↦ (Blob -> UpdateFunc)
  query_methods : MethodName ↦ (Blob -> QueryFunc)
}
....

This high-level interface presents a pure, mathematical model of a canister, and hides the bookkeeping required to provide the System API as seen in Section <<system-api>>.

Parameters like `Entropy` and `CanId` are merely passed through to the canister, via the `msg.entropy` and `canister.self` system calls.

The concrete mapping of this abstract `CanisterModule` to actual WebAssembly concepts and the System API is described separately in section <<concrete-canisters>>.

==== Call contexts

The DFINITY Internet Computer provides certain messaging guarantees: If a user or a canister calls another canister, it will eventually get a single response (a reply or a rejection), even if some canister code along the way fails.

To ensure that only one response is generated, and also to detect when no response can be generated any more, we maintain a _call context_. The `replied` field is set to `true` once the call has received a response, further attempts to send a response fail.

....
CallCtxt = {
  canister : CanId;
  caller : CallOrigin;
  replied : bool;
}
CallId = (abstract)
CallOrigin
  = FromUser {
      api_message : APIMessage;
    }
  | FromCanister {
      calling_context : CallId;
      callback: Response -> WasmFunc
    }
....

In this abstract description, call contexts are never garbage collected, even if nothing references them any more; an implementation can do that.

==== Calls and Messages

Calls into and within the DFINITY Internet Computer are implemented as messages passed between canisters. During their lifetime, messages change shape: they begin as a call to a public method, which is resolved to a WebAssembly function that is then executed, potentially generating a response which is then delivered.

NOTE: These messages are a different thing from the messages that occur in the HTTPS API; the latter are called API Messages in this document.

Therefore, a message can have different shapes:
....
Queue = Unordered | Queue { from : CanId; to : CanId }
Message
  = CallMessage {
      caller : CallOrigin;
      callee : CanId;
      method_name : Text;
      arg : Blob;
      queue : Queue;
    }
  | FuncMessage {
      call_context : CallId;
      receiver : CanId;
      func : UpdateFunc;
      queue : Queue;
    }
  | ResponseMessage {
      call_context : CallId;
      response : Response;
    }
....

The `queue` field is used to describe the message ordering behavior. Its concrete value is only used to determine when the relative order of two messages must be preserved, and not otherwise interpreted. Response messages are not ordered, as explained above, so they have no `queue` field.

Although the `func` field of `FuncMessage` has type `UpdateFunc`, it could also be a query call. We will see below that an `QueryFunc` can be modeled as an `UpdateFunc`.

A reference implementation would likely maintain a separate list of `messages` for each such queue to efficiently find eligible messages; this document chooses this approach for a simpler and more concise system state.

==== API messages

We distinguish between the _asynchronous_ API messages passed to `/api/v1/submit`, which may be present in the system state, and the _synchronous_ API messages passed to `/api/v1/read`, which are only ephemeral.

The `sender` field is always the id of the user who submits the message, and is authenticated (once we have defined signatures).

....
APIMessage
  = RegisterCanister = {
    nonce : Blob;
    sender : UserId;
    sender_sig : Signature;
  }
  | RegisterUser = {
    nonce : Blob;
    sender : UserId;
    sender_sig : Signature;
    public_key : PublicKey;
  }
  | InstallCode = {
    nonce : Blob;
    sender : UserId;
    sender_sig : Signature;
    canister_id :  CanId;
    module : CanisterModule;
    arg : Blob;
  }
  | CanisterUpdateCall = {
    nonce : Blob;
    sender : UserId;
    sender_sig : Signature;
    callee : CanId;
    method_name : Text;
    arg : Blob;
  }
....

The evolution of an `APIMessage` goes through these states:
....
APIMessageStatus
  = Accepted
  | Processing
  | Failed (RejectCode, Text)
  | Completed { result : Value }
....

The transitions are the following:

[plantuml]
....
(*) --> "Client creates message" #DDDDDD
   --> "Submitted" #DDDDDD
   --> "Accepted"
   --> "Processing"
if "" then
  --> "Completed"
  --> "Expired" #DDDDDD
  else
  --> "Failed"
  --> "Expired" #DDDDDD
endif
....

Note that all gray states are _not_ represented in the system state, and are indistinguishable from “message does not exist”. In order to avoid replay-attacks, messages have a limited validity, and the last transition (forgetting the message) must happen after the message’s expiry field invalidates it.

The states `Accepted` and `Processing` are for internal bookkeeping, both are presented as “Accepted” to the user. The processing state may be skipped for certain messages.


These are the synchronous read messages:

....
APIReadMessage
  = ReadStatus = {
    message_id : MessageId
  }
  | CanisterQuery = {
    callee : CanId;
    method_name : Text;
    arg : Blob;
  }
....

A `ReadStatus` refers to a message by way of a _message id_, which is a hash of the message content:
....
MessageId = Blob
message_id_of : APIMessage -> MessageId
....

The precise algorithm to calculate this message id is specified in <<api-message-id>>.

[#abstract-signature]
==== Abstract signature scheme

The precise signature scheme is not yet specified, but we can already abstractly describe how signing interacts with the system, which messages are signed, and where the signature is verified.

To this end we assume abstract types for public keys (or hashes thereof), a function verifies the signature on an `APIMessage` and a function that extracts the public key from a signature:
....
Signature = Blob
PublicKey = Blob
verify_signature : APIMessage -> Signature -> Bool
public_key_of_signature : Signature -> PublicKey
....

==== The system state

Finally, we can describe the state of the DFINITY Internet Computer as a record having the following fields:

....
S = {
  api_messages : APIMessage ↦ APIMessageStatus ;
  users : UserId ↦ UserData;
  canisters : CanId ↦ CanState;
  admins : CanId ↦ Set UserId;
  call_contexts : CallId ↦ CallCtxt;
  messages : List Message; // ordered!
}
CanState = EmptyCanister | {
  wasm_state : WasmState;
  module : CanisterModule;
}
UserData = {
  public_keys : Set PublicKey
}
....

==== Initial state

The initial state of the system is
....
{
  api_messages = ();
  users = ();
  canisters = ();
  admins = ();
  call_contexts = ();
  messages = ();
}
....
using `()` to denote the empty map or bag.

=== State transitions

Based on this abstract notion of the state, we can describe the behavior of the system. There are three classes of behaviors:

 * Asynchronous API messages that are submitted via `/api/v1/read`. These transitions describes checks that the message must pass to be accepted.
 * Spontaneous transitions that model the internal behavior of the system, by describing conditions on the state that allow the transition to happen, and the state after.
 * Responses to reads (i.e. `/api/v1/read`). By definition, these do _not_ change the state of the system, and merely describe the response based on the read message and the current system state.

The state transitions are not complete with regard to error handling. For example, the behavior of sending a message to a non-existent canister is not specified here. For now, we trust our team to make sensible decisions there.

==== API Message submission

After a node accepts a message via `/api/v1/submit`, it gets added to the system in the `Accepted` state.

This may only happen if the following validation steps pass:

 * The signature on the message is valid.
 * The key used to sign the message is among the sending user’s public keys.

More validation (e.g. authorization) steps may be added here.

Submitted message:: `M`
Conditions::
....
    verify_signature M M.sender_sig = true
    public_key_of_signature M.sender_sig ∈ S.users[M.sender].public_keys
....
State after::
....
S with
    api_messages[M] = Accepted
....

NOTE: This is not instantaneous (the system takes some time to agree it accepts the message) nor guaranteed (a node could just drop the message, or maybe it did not pass validation). But once it has entered the system like this, it will be acted upon.

NOTE: Due this check, the `sender` field of any message in the system state is authenticated, so an implementation may actually drop the `sender_sig` field at this point.

==== User registration

User registration api message have the effect of allocating a fresh user id:

Conditions::
....
    S.api_messages[RegisterUser M] = Accepted
    UserId ∉ (dom S.users ∪ dom S.canisters)
....
State after::
....
S with
    api_messages[RegisterUser M] = Completed { result = { user_id = UserId } }
    users[UserId] = {
      public_keys = { M.public_key }
    }
....

==== Canister registration

A Canister registration api message has the effect of allocating a fresh canister id:

Conditions::
....
    S.api_messages[RegisterCanister M] = Accepted
    CanId ∉ dom S.canisters
....
State after::
....
S with
    api_messages[RegisterCanister M] = Completed { result = { canister_id = CanId } }
    canisters[CanId] = EmptyCanister
....

==== Canister code installation

Only an admin of the given canister can install new code. This turns an empty canister into a running canister. This involves invoking the `dfn_init` system method (see <<system-api-init>>), which must succeed and must not invoke other methods.

The value `R : i64` is cryptographically randomly chosen.

Conditions::
....
    S.api_messages[InstallCode M] = Accepted
    S.canisters[M.canister_id] = EmptyCanister
    M.sender ∈ S.admins[M.canister_id]
    M.module.init (FreshEntropy R, M.arg) =
      Return { new_state = New_state; new_calls = (); response = NoResponse }
....
State after::
....
S with
    api_messages[InstallCode M] = Completed { result = { } }
    canisters[M.canister_id] = { wasm_state = New_state; module = M.module }
....

===== Initiating canister calls

A first step in processing a canister update call is to create a `CallMessage` in the message queue.

The `api_message` field of the `FromUser` caller establishes the connection to the api message. One could use the corresponding `message_id_of` for this purpose, but this formulation is more abstract.

We do not make any guarantees about the order of incoming messages.

Conditions::
....
    S.api_messages[CanisterUpdateCall M] = Accepted
....
State after::
....
S with
    api_messages[CanisterUpdateCall M] = Processing
    messages =
      CallMessage {
        caller = FromUser { api_message = CanisterUpdateCall M };
        callee = M.callee;
        method_name = M.method_name;
        arg = M.arg;
        queue = Unordered;
      } · S.messages
....

==== Call context creation

Before invoking a message to a public entry point, some bookkeeping is required: A call context is created, and the method is looked up in the list of exports. This happens for both ingress and inter-canister messages.

The position of the message in the queue is unchanged.

Conditions::
....
    S.messages = Older_messages · CallMessage CM · Younger_messages
    S.canisters[CM.callee] ≠ EmptyCanister
    M = S.canisters[CM.callee].module
    F = if M.method_name ∈ M.update_methods
        then M.update_methods[CM.method_name]
        else query_to_update_func (M.query_methods[CM.method_name])
    Ctxt_id ∉ dom S.call_contexts
....
State after::
....
S with
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id;
        receiver = CM.callee;
        func = F (CM.arg)
        queue = CM.queue;
      } ·
      Younger_messages
    call_contexts[Ctxt_id] = {
      canister = CM.callee;
      caller = CM.caller;
      replied = false;
    }
....

The function `query_to_update_func` simply turns a query function into an update function, this is merely a notational trick to simplify the message execution rules:
....
query_to_update_func f =
  λ blob → λ (entropy, self_id, wasm_state) →
    match f(blob)(self_id, wasm_state) with
      Trap → Trap
      Return res → Return {
        new_state = wasm_state;
        new_calls = [];
        response = res;
      }
....
Note that by construction, a query function will either trap or return with a response; it will never send calls, and it will never change the state of the canister.

==== Message execution (non-trapping)

We can execute any message that is at the head of its queue, i.e. there is no
older message with the same abstract `queue` field.
The actual message execution, if successful, may enqueue further messages and
-- if the function returns a response -- record this response.
The new call and response messages are enqueued at the end.

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    S.canisters[C.callee] ≠ EmptyCanister
    M.func(FreshEntropy R, M.receiver, S.canisters[M.receiver].wasm_state) = Return res
    (res.response = NoResponse) or (S.call_contexts[M.call_context].replied = false)
....
State after::
....
S with
    canisters[M.receiver].wasm_state = res.new_state;
    messages =
      Older_messages ·
      Younger_messages ·
      [ CallMessage {
          caller = FromCanister {
            call_context = M.call_context;
            callback = call.callback
          };
          callee = call.callee;
          method_name = call.method_name;
          arg = call.arg;
          queue = Queue { from = M.receiver; to = call.callee };
        }
      | for call ∈ res.new_calls ] ·
      [ ResponseMessage {
          call_context = M.call_context;
          response = res.response;
        }
      | if res.response ≠ NoResponse ]

     // only if res.response ≠ NoResponse:
     call_contexts[M.call_context].replied = true
....

==== Message execution (trapping)

If a message traps, it gets dropped. No response is generated (some other message may still fulfill this calling context).

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    S.canisters[M.callee] ≠ EmptyCanister
    M.func(FreshEntropy R, M.receiver, S.canisters[M.receiver].wasm_state) = Trap
....
State after::
....
S with messages = Older_messages · Younger_messages
....

==== Message execution (double response)

If a message tries to respond when its calling context has already be responded to, then we treat it like a trapping message.

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    S.canisters[M.callee] ≠ EmptyCanister
    M.func(FreshEntropy R, M.receiver, S.canisters[M.receiver].wasm_state) = Return res
    S.call_contexts[M.call_context].replied = true
    res ≠ NoResponse
....
State after::
....
S with messages = Older_messages · Younger_messages
....

==== Call context starvation

If there is no call, downstream calling context or response that could possibly fulfill a calling context, then a reject is synthesized. The error message below is _not_ indicative. In particular, if the system has an idea about _why_ this starved, it can put that in there (e.g. the initial message handler trapped with an out-of-memory access).

Conditions::
....
    S.call_contexts[Ctxt_id].replied = false
    ∀ CallMessage msg ∈ S.messages. msg.call_context ≠ Ctxt_id
    ∀ ctxt_ids.
        (S.call_contexts[ctxt_ids].replied = false || S.response[ctxt_ids] exists)
        ==> S.call_contexts[ctxt_ids].caller.calling_context ≠ Ctxt_id
....
State after::
....
S with
    call_contexts[Ctxt_id].replied = true
    messages =
      S.messages ·
      ResponseMessage {
        call_context = Ctxt_id;
        response = Reject (CANISTER_ERROR, "starvation");
      }
....

==== Callback invocation

When an inter-canister call has been responded to, we can queue the call to the callback.

Conditions::
....
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    S.call_contexts[RM.call_context].origin =
      FromCanister {
        call_context = Ctxt_id2
        callback = F
      }
....
State after::
....
S with
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id2
        receiver = S.call_contexts[RM.call_context].canister
        func = F (RM.response)
        queue = Unordered
      } ·
      Younger_messages
....


==== Respond to user message

When an ingress method call has been responded to, we can record the response in the list of queries.

Conditions::
....
    S.api_messages[M] = Processing
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    S.call_contexts[RM.call_context].origin = FromUser { api_message = M }
....
State after::
....
S with
    messages = Older_messages · Younger_messages
    api_messages[M] =
      | Completed { result = R } if response = Reply R
      | Failed R                 if response = Reject R
....

==== API Message expiry

At some point, a processed message can expire. Precise conditions are yet to be determined.

Conditions::
....
    (S.api_messages[M] = Completed _) or (S.api_messages[M] = Failed _)
....
State after::
....
S with
    api_messages[M] = (deleted)
....


==== Read: Status

The user can query the status of a request. The type of `result`, given as `Value` in the above spec, can vary depending on the request type.

NOTE: There is a phase where a request was issued by the client, but not accepted yet by the whole system. During this phase, the request status behaves as if the request has never been seen. It may silently be dropped, or eventually be marked as accepted, as seen in the following rules.

Read message:: ReadStatus { message_id = MI }
Conditions::
....
   message_id_of(M) = MI
   S.api_messages[M] = MS
....
Read response::
A record with
* `{status: accepted}` if `MS = Accepted` or `MS = Processing`
* `{status: rejected; reject_code: <code>: reject_message: <msg>}` if `MS = Failed (code, msg)`
* `{status: completed; result : <result>}` if `MS = Completed { result = result }`

==== Read: query call

Canister query calls can be executed directly.

Read message:: CanisterQuery Q
Conditions::
....
  S.canisters[Q.callee] ≠ EmptyCanister
  C = S.canisters[Q.callee]
  F = C.module.query_methods[Q.method_name]
....
Read response::
* If `F(Q.callee, Q.arg) = Trap` then
+
....
{status: failed; error: "Query execution trapped"}
....
* Else if `F(Q.callee, Q.arg) = Return (Reject (code, msg))` then
+
....
{status: rejected; reject_code: <code>: reject_message: <msg>}
....
* Else if `F(Q.callee, Q.arg) = Return (Reply R)` then
+
....
{status: success; result: <R> }
....


[#concrete-canisters]
=== Abstract Canisters to System API

In Section <<abstract-canisters>> we introduced an abstraction over the interface to a canister, to avoid cluttering the abstract specification of the DFINITY Internet Computer from WebAssembly details. In this section, we will fill the gap and explain how the abstract canister interface maps to the <<system-api,concrete System API>> and the WebAssembly concepts as defined in the https://webassembly.github.io/spec/core/index.html[WebAssembly specification].

==== The concrete `WasmState`

The abstract `WasmState` maps to the WebAssembly _store_ `S`, which encompasses the functions, tables, memories and globals of the WebAssembly program.

As explained in Section “<<system-api-module>>”, the WebAssembly module imports at most _one_ memory and at most _one_ table; in the following, _the_ memory (resp. table) and the fields `mem` and `table` of `S` refer to that. Any system call that accesses the memory (resp. table) will trap if the module does not import the memory (resp. table).

We model `mem` as an array of bytes, and `table` as an array of execution functions.

==== The execution state

We can model the execution of WebAssembly functions as stateful functions that have access to the WebAssembly store. In order to also model the behavior of the system imports, which have access to additional data structures, we extend the state as follows:
....
Params = {
  arg : NoArg | Blob;
  reject_code : 0 | SYS_FATAL | SYS_TRANSIENT | …;
  reject_message : Text;
}
PartialCall = {
  callee : CanId;
  method : MethodName;
  arg : Blob;
  on_reply : StillMissing;
  on_reply_env : i32;
  on_reject : StillMissing;
  on_reject_env : i32;
  performed : Bool;
}
ExecutionState = {
  wasm_state : S; // a store as per WebAssembly spec
  api_nonce : (abstract)
  self_id : CanId;
  params : Params;
  entropy : Entropy;
  response : NoResponse | Response;
  reply_params : { arg : Blob };
  calls : List PartialCall;
  performed_calls : List Call
}

....

This allows us to model WebAssembly functions, including host-provided imports, as functions with implicit mutable access to an `ExecutionState`, dubbed _execution functions_.
Syntactically, we express this using an implicit argument of type `ref ExecutionState` in angle brackets (e.g. `func<es>(api_nonce)` for the invocation of a WebAssembly function with type `+(api_nonce : anyref) -> ()+`).  The lifetime of the `ExecutionState` data structure, and the `api_nonce`, is that one invocation of such a function.

WARNING: It is nonsensical to pass to an execution function a `WasmState` that comes from a different WebAssembly module than one defining the function The current specification does not do that, because every canister gets instantiated exactly once. Once we add upgrading to this document this needs to be checked.

==== The concrete `CanisterModule`

Finally we can specify the abstract `CanisterModule` that models a concrete WebAssembly module.

* The `initial_wasm_state` mentioned below is the store of the WebAssembly module after _instantiation_ (as per WebAssembly spec) of the WasmModule contained in the <<canister-module-format,canister module>>, including executing a potential `(start)` function.

* For more convenience when creating a new `ExecutionState`, we define the following partial record:
+
....
empty_execution_state = {
  wasm_state = (undefined);
  api_nonce = (undefined);
  self_id = (undefined);
  params = (undefined);
  entropy = (undefined);
  response = NoResponse;
  reply_params : { arg = "" };
  calls : [];
  performed_calls : [];
}
....


* The `init` field of the `CanisterModule` is defined as follows:
+
If the WebAssembly module does not export a function called under the name `dfn_init`, we have
+
....
init = λ (entropy, self_id, blob) →
  if |blob| > 0
  then Trap
  else Return initial_wasm_state
....
+
Otherwise, if the WebAssembly module exports a function `f` under the name `dfn_init`, it is
+
....
init = λ (entropy, self_id, blob) →
  let es = ref {empty_execution_state with
      wasm_state = initial_wasm_state;
      api_nonce = fresh_nonce();
      self_id = self_id;
      entropy = entropy;
      params = { arg = blog; reject_code = 0; reject_message ""}
    }
  try func<es>(es.api_nonce) with Trap then Trap
  if es.performed_calls ≠ [] then Trap
  if es.response ≠ NoResponse then Trap
  Return es.wasm_state
....
+
This formulation checks afterwards that the system calls `call.perform` or `msg.reply` were not invoked; an implementation can of course trap already when these system calls are invoked.

* The partial map `update_methods` of the `CanisterModule` is defined for all method names `meth` for which the WebAssembly program exports a function `f` named `dfn_update <meth>`, and has value
+
....
update_methods[meth] = λ blob → λ (entropy, self_id, wasm_state) →
  let es = ref {empty_execution_state with
      wasm_state = wasm_state;
      api_nonce = fresh_nonce();
      self_id = self_id;
      entropy = entropy;
      params = { arg = blog; reject_code = 0; reject_message = "" }
    }
  try func<es>(es.api_nonce) with Trap then Trap
  Return {
    new_state = es.wasm_state;
    new_calls = es.performed_calls;
    response = es.response;
  }
....

* The partial map `query_methods` of the `CanisterModule` is defined for all method names `meth` for which the WebAssembly program exports a function `f` named `dfn_query <meth>`, and has value
+
....
query_methods[meth] = λ blob → λ (self_id, wasm_state) →
  let es = ref {empty_execution_state with
      wasm_state = wasm_state;
      api_nonce = fresh_nonce();
      self_id = self_id;
      entropy = NoEntropy;
      params = { arg = blog; reject_code = 0; reject_message ""}
    }
  try func<es>(es.api_nonce) with Trap then Trap
  if es.performed_calls ≠ () then Trap
  if es.response = NoResponse then Trap
  Return es.response;
....
+
This formulation checks afterwards that the system calls `call.perform` was not invoked; an implementation can of course trap already when these system calls have been invoked.
+
By construction, the (possibly) modified `es.wasm_state` is discarded.


==== Host references

The System API defines various WebAssembly reference types (`api_nonce`, `canisterref`, `methref`, `callref`), all passed as a WebAssembly `anyref`. These are opaque to the WebAssembly code, but transparent to our System API. So we model a value of type `anyref` as follows:
....
type anyref
  = APIRef (abstract)
  | CanisterRef CanId
  | MethodRef (CanId, MethodName)
  | CallRef Nat
....

The syntax `let MethodName (c, m) = ref else Trap` indicates that a system functions extracts the values `c` and `m` from a `methref`, trapping if the reference is not actually a `methref`. In the future, with the _type import_ WebAssembly proposal, module validation will ensure that these different variants of references are properly distinguished by type.

==== System imports

Upon _instantiation_ of the WebAssembly module, we can provide the following executions functions as imports.

....
msg.arg_data_size<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.params.arg = NoArg then Trap
  return |es.params.arg|

msg.arg_data_copy<es>(api_nonce : anyref, dst:i32, length:i32, offset:i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.params.arg = NoArg then Trap
  if offset+length > |es.params.arg| then Trap
  if dst+length > |es.wasm_state.mem| then Trap
  es.wasm_state.mem[dst..dst+length] := es.params.arg[offset..offset+length]

msg.reject_code<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  es.params.reject_code

msg.reject_msg_len<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.reject_code = 0 then Trap
  return |es.params.reject_msg|

msg.reject_msg_copy<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.reject_code = 0 then Trap
  if offset+length > |es.params.reject_msg| then Trap
  if dst+length > |es.wasm_state.mem| then Trap
  es.wasm_state.mem[dst..dst+length] := es.params.reject_msg[offset..offset+length]

msg.reply_data_append<es>(api_nonce : anyref, offset : i32, length : i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  if offset+length > |es.wasm_state.mem| then Trap
  es.reply_params.arg := es.reply_params.arg · es.wasm_state.mem[offset..offset+len];

msg.reply<es>(api_nonce : anyref) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  es.response := Reply (es.reply_params.arg)

msg.reject<es>(api_nonce : anyref, offset : i32, length : i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  if offset+length > |es.wasm_state.mem| then Trap
  es.response := Reject (CANISTER_REJECT, es.wasm_state.mem[offset..ofset+len])

canister.lookup<es>(api_nonce : anyref, canister_id : i64) : anyref =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  return (CanisterRef canister_id)

canister.id<es>(api_nonce : anyref, canister_ref : anyref) : 64 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  let CanisterRef canister_id = canister_ref else Trap
  return canister_id

canister.self<es>(api_nonce : anyref) : anyref =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  return (CanisterRef es.self_id)

meth.public<es>(
  api_nonce    : anyref,
  canister_ref : anyref,
  name_offset  : i32,
  name_len     : i32,
) : ( anyref ) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  let CanisterRef callee = canister_ref else Trap
  if name_offset+name_len > |es.wasm_state.mem| then Trap

  return (MethodRef callee es.wasm_state.mem[name_offset..name_offset+name_len])

call.create<es>(
  meth_ref   : anyref,
) : ( anyref ) =
  let MethodRef callee method_name = meth_ref else Trap

  callref := |es.calls|
  es.calls := es.calls ·
   {
      callee = callee;
      method_name = method_name;
      arg = "";
      on_reply = StillMissing;
      on_reply_env = 0;
      on_reject = StillMissing;
      on_reject_env = 0;
      performed = False;
    }
  return callref

call.arg_data_append<es>(callref : anyref, offset : i32, len : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if offset+len > |es.wasm_state.mem| then Trap

  es.calls[callidx].arg := es.calls[callidx].arg · es.wasm_state.mem[offset..offset+len];

call.on_reply<es>(callref : anyref, fun : i32, env : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if fun > |es.wasm_state.table| then Trap
  if typeof(es.wasm_state.table[fun]) ≠ func (anyref, i32) -> () then Trap
  if es.calls[callidx].on_reply ≠ StillMissing then Trap

  es.calls[callidx].on_reply := es.wasm_state.table[fun]
  es.calls[callidx].on_reply_env := env

call.on_reject<es>(callref : anyref, fun : i32, env : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if fun > |es.wasm_state.table| then Trap
  if typeof(es.wasm_state.table[fun]) ≠ func (anyref, i32) -> () then Trap
  if es.calls[callidx].on_reject ≠ StillMissing then Trap

  es.calls[callidx].on_reject := es.wasm_state.table[fun]
  es.calls[callidx].on_reject_env := env

call.perform<es>(callref : anyref) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if es.calls[callidx].on_reply = StillMissing then Trap
  if es.calls[callidx].on_reject = StillMissing then Trap

  es.calls[callidx].performed := True

  pc := es.calls[callidx]
  es.performed_calls := es.performed_calls ·
    {
      callee = pc.callee;
      method_name = pc.method_name;
      arg = pc.arg;
      callback = λ response → match response with
        Reply blob → mkWasmFunc
          ( { arg = blob; reject_code = 0 }
          , λ<es'>(api') → pc.on_reply<es'>(api', pc.onreply_env)
          )
        Reject (reject_code, _message) → mkWasmFunc
          ( { arg = NoArg; reject_code = reject_code }
          , λ<es>(api') → pc.on_reject<es'>(api, pc.onreject_env)
          )
    }

msg.entropy<es>(api_nonce : anyref) : i64 =
  if api_nonce ≠ es.api_nonce then Trap
  let (FreshEntropy x) = es.entropy else Trap
  return x

debug.print<es>(offset : i32, len : i32) =
  return

debug.trap<es>(offset : i32, len : i32) =
  Trap
....


== Discussion and comments

=== User and user key management

We have left it up to the state transition (admin) to assign UserId to public keys. In principle a UserId can be associated with several public keys. A public key on the other hand can map to at most one user. A simpler setting would be a bijection between keys and users, or even to have no user ids at all and just refer to public keys.

Currently the life cycle of a public key is existence or non-existence. A more fine-grained life cycle would be: pre-activation, active, suspended, revoked, deleted. Keys may also have usage constraints e.g. a user may want to have a not-so-secure key with a daily spending cap and very-secure key for high value transactions. And keys may come with activation/expiration times.

It is open whether UserId's are deleted if they have no associated public keys. If they are, there might be overlaps in UserId's over time. This could be avoided by guaranteeing a UserId is only used once, e.g., by incremental numbering (or something else to avoid races for special numbers) or using large random numbers.

As with keys, user ids and user accounts will also be subject to management. Their statuses can be: pre-activation, active, suspended, blacklisted, deleted. There may be usage constraints associated with them, and they may hold public information about a user, e.g., name.

In the future we want explicit interfaces over which a user registers a public key and manage their accounts. One could imagine the user creating an ingress message with new public key, optional existing user id, registration evidence (e.g. signature by existing public key or evidence of PKI certificate), user info (e.g. name or KYC), and signature on everything. Similarly, we would need methods for other types of key management and user management.
