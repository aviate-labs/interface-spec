= Public DFINITY interfaces
Joachim Breitner <joachim@dfinity.org>
:toc2:
:toclevels: 2
:stem: latexmath
:source-highlighter: rouge
:icons: font

== Status/Contact

This document is work in progress, initally editored by mailto:joachim@dfinity.org[Joachim]. My initial focus is initially to get the _shape_ of this document right (i.e. what does it cover), and in doing so, will boldy make wild assumptions. I will need your help to correct these eventually, and either adjust the content to reality, or at least to our actual plans.

At some point, this document will be authorative, and will provide a place and a language to discuss features of DFINITY in a helpfully concrete way. Because of its focus on the externally visible behaviour of DFINITY, it will also help uncover abstraction leaks. It should also be a document that we can publish to users of DFINITY.

It will be everyone’s shared responsibility to keep this document accurate, but the editor’s responsibility to keep it focused and consistent. If you have additions or corrections, either talk to Joachim in whatever form you prefer, or propose changes to the document directly (but be prepared for editorial rewrites of your text).

*Status:* We are figuring our the right structure and scope of the document itself, using just core functionality of DFINITY as the working example.


== Introduction

Welcome to the DFINITY Internet Computer! We speak of “the” DFINITY Internet Computer, because although under the hood, a large number of physical computers are working together in non-trivial ways, in the end we have the appearance of a single, shared, secure and world-wide accessible computer. Much, if not all, of the advanced and complex machinery is hidden from those that use the DFINITY computer to run their applications and those who use these applications.

This documents describes this external view of the DFINITY Internet Computer:
Which interfaces it provides to applicaion developers and users, and what will happen when you use these interfaces.

WARNING: While this document describes the public interface and behaviour of the DFINITY Internet Computer, it is not the primary end-user documentation. DFINITY provides further tools, such as the ActorScript programming language, the IDL tooling and the SDK tools, to make programming and using the DFINITY Internet Computer even more convenient. As an end-user, you might want to start with #TODO#.


To the extent possible, this document will _not_ talk about blockchain, consensus protocols, nodes, subnets and orthogonal persistence. If you want to learn more about the exciting inner workings of DFINITY, please consult the link:component-architecture{outfilesuffix}[Component Architecture].

== Overview

If you want to use the DFINITY Internet Computer as an application developer, you first create a _canister module_ that contains the WebAssembly code and configuration for your application, and deploy it using the <<rest-interface,public REST interface>>. You can create canisters using the ActorScript langauge and the DFINITY SDK (#TODO: Link to SDK docs#), which is more convenient. If you want to use your own tooling, however, then this document describes <<canister-module-format,how a canister module looks like>> and how the <<system-api,WebAssembly code can interact with the system>>.

Once your application is running on DFINITY, it is a _canister_, and users can interact with it. They can use the <<rest-interface,public REST interface>> to send _ingress messages_ to the canister, which are eventually delivered to the canister, according to the <<system-api,System API>>.

The user can also use the REST interface to issue read-only queries, which are faster, but cannot change the state of the canister.



.A typical use of the DFINITY computer. (This is a simplified view; some of the arrows represent multiple interaction steps.)
[plantuml]
....
actor Developer
actor User
participant DFINITY
participant "Canister 1" as Can1
Developer -> DFINITY : /canister/new
create Can1
DFINITY -> Can1 : create
DFINITY -> Can1 : initialize
Developer <-- DFINITY : canister-id=1
|||
User -> DFINITY : /canister/1/hello/call
DFINITY -> Can1 : hello
return "Hello world!"
User <-- DFINITY : "Hello World!"

....


The following section describes these interfaces, together with a brief description of what they do. Afterwards, you will find a slightly <<public-spec,more formal description>> of the DFINITY Internet Computer that more precisely describes its behaviour.

== Public Interfaces

[#rest-interface]
=== REST Interface

You can interact with the DFINITY Computer using a typical rest interface.

This documents does not explain how to find the location and port of a running DFINITY node. If you use a local node, you can use `http://127.0.0.1:4200/`.

The following API calls are provided, and explained below:
....
/api/request/<request-nonce>/status
/api/canister/new
/api/canister/<canister-id>/<method-name>/call
/api/canister/<canister-id>/<method-name>/query
....



[#api-request-status]
==== Polling request status

Path:: `/api/request/<request-nonce>/status`
Method:: `GET`
Response format:: JSON record with these fields:
 * `status`: one of `pending`, `failed` or `completed`
 * `result`: (if status is `completed`) A result according to the method spec below.
 * `error` (text): (if status is `failed`) An error message

Some API calls below are asynchronous, i.e. the response is not immediately
returned to the client. In these cases, a _request nonce_ is returned, and this request can be used to query its state or fetch the final result.

==== Deploying a new canister

Path:: `/api/canister/new`
Method:: `POST`
Payload format:: A <<canister-module-format,canister module>>
Response format:: JSON record with these fields
 * `request-nonce`: A unique number identifying the request

Uploading a new canister will install this canister, and invoke its `start` method as explained below #TODO link#.

#TODO: Canister parameters -- in canister module or in the request?#

If the canister installation succeeds, the `result` of <<api-request-status,`/api/request/<request-nonce>/status`>> is a JSON record with these fields:

* `canister-id` (64 bit number): ID of the newly created canister

[#api-canister-call]
==== Sending a message to a canister

Path:: `/api/canister/<canister-id>/<method-name>/call`
Method:: `POST`
Payload format:: JSON record with these fields:
 * `payload` (blob): Payload of the message

Response format:: JSON record with these fields
 * `request-nonce`: A unique number identifying the request

If the method execution succeeds, the `result` of <<api-request-status,`/api/request/<request-nonce>/status`>> is a blob representing the response of the message call.

[#api-canister-query]
==== Fast-track read-only query

Path:: `/api/canister/<canister-id>/<method-name>/query`
Method:: `POST`
Payload format:: JSON record with these fields:
 * `payload` (blob): Payload of the message

Response format:: JSON record with these fields
 * `status`: one of `failed` or `completed`
 * `result` (blob): (if status is `completed`) the response of the query
 * `error` (text): (if status is `failed`) An error message

Canister methods that do not change the canister state can be executed more efficiently. This method provides that ability, and returns the result synchronously.

[#canister-module-format]
=== Canister module format

A canister module is simply a https://webassembly.github.io/spec/core/index.html[WebAssembly module] in binary format (typically `.wasm`).

WARNING: This is a scaffolding spec, close to the current implementation. It will need refinement for features like initialization parameters, dynamically linked libraries. We probably want to go for some zip-file-with-metadata approach.


[#system-api]
=== Canister interface (System API)

The System API is the interface between the running canister and the DFINITY Internet Computer. It allows the WebAssembly module of a canister to expose functionality to the users (method entry points) and the system (e.g. initialization), and exposes system functionality to the canister (e.g. sending further messages). Because WebAssembly is rather low-level, it also explains how to express higher level concepts (e.g. binary blobs).

==== The API nonce

A design goal of the System API is that the canister can restrict which parts of its code can use it. Therefore, all calls into the canister have an `api_nonce` parameter, and all calls into the system require such an parameter. Because this parameter is a WebAssembly host reference (type `anyref`), it cannot be forged.

NOTE: Until WebAssembly host references are available, a hard-to guess `i64` number is used.

==== Accepting messages

To define a public method of name `name`, a WebAssembly module exports a function with name `dfn_msg_<name>` and type `+(api_nonce : anyref) -> ()+`. We call this the _message entry point_.

The payload of the message (e.g. the content of the `payload` field in the <<api-canister-call,API call to send messages>>) is copied into the canister on demand.
 In the success callback for a further <<system-api-send,message send>>, the payload refers to the response of that call; in error callbacks, no payload is available. In other words, the lifetime of the payload is a single WebAssembly function execution, not a whole call tree.

* `+msg.arg_size : (api_nonce : anyref) : i32+`
+
Size, in bytes, of the message payload.

* `+msg.arg_copy : (api_nonce : anyref, dst : i32, length : i32, offset : i32) -> ()+`
+
Copies `length` bytes from `msg_payload[offset..offset+length]` to `heap[dst..dst+length]`, i.e., from the message payload into the Wasm heap.
+
This traps if `offset+length` is greater than the size of the message payload, or if `dst+length` exceeds the size of the Wasm heap, or if called from inside an error callback (see below).

Eventually, the canister will want to respond to the original message, either with success or by signalling an error:

* `+msg.reply : (api_nonce : anyref, offset : i32, length : i32) -> ()+`
+
Replies to the sender with the bytes at `heap[offset..offset+length]`. Traps if `offset+length` exceeds the size of the WebAssembly heap.
+
This method can be called at most once (a second call will trap), and must be called exactly once to indicate success.

* `+msg.reject : (api_nonce : anyref, errorcode : i32) -> ()+`
+
Replies to sender with the given error code.

If the execution of the message traps for any reason, then all changes to the WebAssembly state, as well as the effect of any externally visible system call (like `msg.reply`, `msg.reject`, `msg.send`), are discarded.

[#system-api-send]
==== Sending messages

A canister can send further messages to other canisters, using the following function call.

* {blank}
+

  msg.send : (
    api_nonce      : anyref,
    dest_id        : i64, // ID of destination canister
    name_offset    : i32, // a pointer to and the length of the
    name_len       : i32, //   destination’s unmangled method name
    payload_offset : i32, // a pointer to and the lenght of the
    payload_len    : i32, //   payload of message to send
    onreply        : i32, // funtab entry (api : i64, env : i32) -> ()
    onreply_env    : i32, // an environment to give back to onreply
    onreject       : i32, // funtab entry (api : i64, env : i32, errorcode : i32) -> ()
    onreject_env   : i32  // an environment to give back to onreject
  ) -> ()
+
This function copies the data referred to by `payload_offset`/`payload_offset` out of the canister, notes the current function table entries at the indices `onreply` and `onreject`, and queues a message to the given destination (but does not send it until the current WebAssembly function returns without trapping).
+
Upon succesful completion of the invoked function, the WebAssembly function specified by the `onreply` parameter is executed, and the response data can be queries using `msg.arg_size`/`msg.arg_copy`. If the function invocation fails, the `onreject` function is executed.
+
Further extensions of this function call will happen by extending the parameter list; thanks to WebAssembly import overloading, Canisters importing the system call at an old version (with fewer function arguments) can still work.
+
This system call traps if the `payload_offset+payload_len` exceeds the size of the WebAssembly heap, or if it is calling during the handling of a <<api-canister-query,read-only query>>.

[#public-spec]
== Abstract public behaviour

The interface above describe the outer edges of the DFINITY Internet Computer, but only provide more than vague, intuitive information about what they actually do. This section aims to address that question with great precision, by describing the _abstrac state_ of the whole DFINITY Internet Computer, and how this state can change in response to API function calls, or spontaneously (modeling asynchronous, distributed or non-deterministic execution).

The design of this abstract specification (e.g. how and where pending messages are stored) are _not_ to be understood to in any way prescribe a concrete implemenation or software architecture. The goals here are formal precision and clarity, but not implementability, so this can lead to different ways of phrasing.

=== Abstract canisters

The <<system-api,WebAssembly System API>> is relatively low-level, and some of its details (e.g. that the payload data is queried using separate calls, and that closures are represented by a function pointer and a number, that method names need to be mangled) would clutter this section. Therefore, we abstract over the WebAssembly details as follows:

* The state of a WebAssembly module (heap, tables, globals) is hidden behind an abstract `WasmState`.

* A canister module `CanisterModule` consists of an initial state, and a (pure) execution function that either indicate that the canister traps, or returns a new state together with a description of the invoked asynchronous system api calls.
+
....
CanId = Nat
ReqId = Nat
MethodName = Text

WasmState = (abstract)
WasmFunc = WasmState -> FuncResult
FuncResult ::=  Trap | Ok {
  new_state : WasmState;
  new_calls : List SendCall;
  result : NoResult | Result;
}
CallResult ::= Reply Blob | Reject ErrCode;
SendCall ::= {
  destination : CanId;
  method: MethodName;
  payload: Blob;
  callback: CallResult -> WasmFunc;
}
CanisterModule ::= {
  initial : WasmState;
  exports : MethodName ↦ (Blob -> WasmFunc)
}
....
+
Note that `WasmFunc` can represent a closure, e.g. a webassembly function with some arguments already applied.

The concrete mapping of `CanisterModule` to actual WebAssembly concepts is described in section #todo#.

=== Abstract system state

The state of the DFINITY Internet computer can be described as a record with the following fields:

....
S ::= {
  requests : ReqId ↦ ReqState;
  canisters : CanId ↦ CanState;
  messages : Set Message;
  to_install : UnorderedList InstallRequest;
}
ReqState
  ::= Pending
  | Failed { message : Text }
  | Completed { result : Value }
CanState ::= {
  wasm_state : WasmState;
  exports : MethodName ↦ (Blob -> WasmFunc);
  call_contexts : CallId ↦ CallCtxt;
}
CallbackId = (abstract)
CallCtxt ::= {
  origin : MsgOrigin;
  replied : bool;
}
MsgOrigin
  ::= FromUser {
      request : ReqId;
    }
  | FromCanister {
      sender : CanId;
      call_context : CallId;
      callback: CallResult -> WasmFunc
    }
  | ResponseMessage {
    call_context : CallId;
  }
Message ::= {
  origin : MsgOrigin
  receiver : CanId
  method : WasmFunc
}
InstallRequest ::= {
  request : ReqId;
  canister : CanisterModule;
}
....


=== Initial state

The initial state of the system is
...
{
  requests = ();
  canisters = ();
  messages = ();
  to_install = ();
}
...
using `()` to denote the empty map/set/list.

=== State transitions

Based on this abstract notion of the state, we can describe the behaviour of the system.

Some transitions are trigged by invoking the REST API; these indicate the REST method parameters and response. Other transitions are modelled as spontaneous, and only have the state before and after.

==== Actor installation request

State before::
....
S
....
REST message::
`/api/canister/new` with body `C : CanisterModule`
State after::
....
S with
    requests[req_id] = Pending
    to_install = { request = req_id; canister = C} · S.to_install
  where
    req_id ∉ dom S.requests
....
REST response::
A JSON record with `{request-nonce: <req_id>}`

==== Request status query

State before::
....
S
....
REST message::
`/api/requests/<req_id>/status`
State after::
....
S
....
REST response::
A JSON record with
* `{status: pending}` if `S.requests[req_id] = Pending`
* `{status: failed; message: <msg>} if `S.requests[req_id] = Failed { message = msg }`
* `{status: completed; result : <result>}` if `S.requests[req_id] = Completed { result = result }`

==== Actor installation

State before::
....
S with
    requests[req_id] = Pending
    to_install = { request = req_id; canister = C} · S.to_install
....
State after::
....
S with
    requests[req_id] = Completed { result = { canister_id = cid } }
    to_install = S.to_install
    canisters[cid] = {
      wasm_state = C.initial;
      call_contexts = ()
    }
....

==== User message send

State before::
....
S
....
REST message::
`/api/canister/<cid>/<meth>/call` with body `{ payload : <payload> }`
State after::
....
S with
    requests[req_id] = Pending
    messages =
      {
        origin = FromUser { request = req_id };
        receiver = cid;
        method = S.canisters[cid](payload).
      } · S.messages
  where
    req_id ∉ dom S.requests
....
REST response::
A JSON record with `{request-nonce: <req_id>}`

==== Message execution (non-trapping)

State before::
....
S with
    messages = M · S.message
  where
    M.method (S.canisters[M.receiver].wasm_state) = Ok res
    ∀ call ∈ M.new_calls:
      S.canisters[call.destination].exports[call.method] exists
....
State after::
....
S with
    messages = S.message · map msg_of_call M.new_calls

msg_of_call call =
  {
     origin : FromCanister {
       sender : M.receiver; 
....
