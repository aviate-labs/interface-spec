= The DFINITY Computer, public view
Joachim Breitner <joachim@dfinity.org>
:toc2:
:toclevels: 3
:stem: latexmath
:source-highlighter: pygments
:icons: font

== Preamble

This document is work in progress, initially authored by mailto:joachim@dfinity.org[Joachim]. The goal is to have a document that is authoritative, and provides a place and a language to discuss public features of DFINITY in a hopefully concrete way. It could also be a document that we can publish to users of DFINITY.

Because of its focus on the externally visible behavior of DFINITY, it will also help uncover abstraction leaks. Because it aims to describe the full behavior, it helps to show which designs are unexpectedly complicated.

=== Contact

It will be everyone’s shared responsibility to keep this document accurate, but the editor’s responsibility to keep it focused and consistent. If you have additions or corrections, either talk to Joachim in whatever form you prefer, or propose changes to the document directly (but be prepared for editorial rewrites of your text).

=== Status

We are figuring our the right structure and scope of the document itself, using just core functionality of DFINITY as the working example.

The basic functionality of installing a canister and canister method calls, should already be rather precise. Beyond that, there are open questions and missing bits (see below). I need your help to correct these, and either adjust the content to reality, or at least to our actual plans.

Please also skim the https://github.com/dfinity-lab/dfinity/pulls?q=is%3Apr+is%3Aopen+%22Public+Spec%22+in%3Atitle[list of open PRs] against this document, to get an overview of ongoing discussions.

=== Open questions and missing bits

As we are fleshing out this document, we get comments that we cannot immediately resolve. In order to not drop them, and make it clear to readers which parts are not done yet, we are briefly collecting them here.

* Rest interface: Structure of the request bodies (JSON or something better)
* Canister IDs: Really just 64 bit numbers, and which textual format?
* Missing: Message ordering is not yet enforced in the formalism.
* Missing: Methods without responses/fire-and-forget calls
* Missing: Deleting request responses after some amount of time.
* Missing: Getting your own canister id
* Missing: Listing well-known error codes.
* Missing: Canister likely need some kind of file store (for IDL specs, static assets, incremental canister module uploads)
* Wrong here: Canister installation: Likely multi-step: Register, upload canister module (possibly incremental if bigger than a message), activate.
* Missing: Canister upgrades.
* Missing: User identity and accounts
* Missing: Payment
* Missing: Gas accounting
* Missing: Subnet ids (e.g. modeling multiple HTTP endpoints, multiple accounts, locality requirements of requests)
* Missing: Time (idea: separate per-canister time, nondeterministic time step transition)
* Missing: Storing and retrieving static data (e.g. the Wasm module itself, its IDL spec, HTML assets)
* Missing (optional): References in call arguments and responses? Which references are supported? Can we have `funcrefs`?
* Missing (optional): Certified variables (globals pointing to memory? specially marked read-only methods?)
* Missing (optional): Programmatic canister creation


== Introduction

Welcome to the DFINITY Internet Computer! We speak of “the” DFINITY Internet Computer, because although under the hood, a large number of physical computers are working together in non-trivial ways, in the end we have the appearance of a single, shared, secure and world-wide accessible computer. Much, if not all, of the advanced and complex machinery is hidden from those that use the DFINITY computer to run their applications and those who use these applications.

=== Scope of this document

This documents describes this external view of the DFINITY Internet Computer:
Which interfaces it provides to application developers and users, and what will happen when you use these interfaces.

WARNING: While this document describes the public interface and behavior of the DFINITY Internet Computer, it is not the primary end-user documentation. DFINITY provides further tools, such as the ActorScript programming language, the IDL tooling and the SDK tools, to make programming and using the DFINITY Internet Computer even more convenient. As an end-user, you might want to start with #TODO#.

If you think of the DFINITY Internet Computer as a distributed execution engine that _provides_ a WebAssembly-based application hosting service, then this document describes exclusively the latter aspect of it. So to the extent possible, this document will _not_ talk about blockchain, consensus protocols, nodes, subnets and orthogonal persistence. If you want to learn more about the exciting inner workings of DFINITY, please consult the link:../index{outfilesuffix}[Component Interface Specifications].

This document tries to be implementation agnostic: If we decide to re-do the implementation of the DFINITY Internet Computer from scratch at some point in the future, then this document would (ideally) still be valid as is.

This implies that this document does not speak of the interface of the DFINITY Internet Computer towards its engineers and administrators, as topics like node update, monitoring, logging are inherently tied to the actual _implementation_ and its architecture.


=== Overview of the Internet Computer

If you want to use the DFINITY Internet Computer as an application developer, you first create a _canister module_ that contains the WebAssembly code and configuration for your application, and deploy it using the <<http-interface,public HTTP interface>>. You can create canisters using the ActorScript language and the DFINITY SDK (#TODO: Link to SDK docs#), which is more convenient. If you want to use your own tooling, however, then this document describes <<canister-module-format,how a canister module looks like>> and how the <<system-api,WebAssembly code can interact with the system>>.

Once your application is running on DFINITY, it is a _canister_, and users can interact with it. They can use the <<http-interface,public HTTP interface>> to send _ingress method calls_ to the canister, which are eventually delivered to the canister, according to the <<system-api,System API>>.

The user can also use the HTTP interface to issue read-only queries, which are faster, but cannot change the state of the canister.



.A typical use of the DFINITY computer. (This is a simplified view; some of the arrows represent multiple interaction steps or polling.)
[plantuml]
....
actor Developer
actor User
participant DFINITY
participant "Canister 1" as Can1
Developer -> DFINITY : /canister/new
create Can1
DFINITY -> Can1 : create
DFINITY -> Can1 : initialize
Developer <-- DFINITY : canister-id=1
|||
User -> DFINITY : /canister/1/hello/call
DFINITY -> Can1 : hello
return "Hello world!"
User <-- DFINITY : "Hello World!"

....

Section “<<interfaces>>” describes these interfaces, together with a brief description of what they do. Afterwards, you will find a <<public-spec,more formal description>> of the DFINITY Internet Computer that describes its abstract behavior with high precision.


== About calls and messages


=== Nomenclature

To get some consistency in this document, we try to use the following terms around method calls and messaging:

The public entry points of canisters are called _methods_. Methods can be _called_, from _caller_ to _callee_, and will eventually incur a _response_ which is either a _reply_ or a _reject_. A method may have _parameters_, which are provided with concrete _arguments_ in a method call. Calls can be _update calls_ (state mutation is preserved) or _query calls_ (state mutation is discarded).

These are implemented using _messages_ from a _sender_ to a _receiver_, messages do not have a response.

WebAssembly  _functions_ are exported by the WebAssembly module or provided by the System API. These are _invoked_ and can either _trap_ or _return_, possibly with a return value. Functions, too, have parameters and take arguments.

=== Ordering guarantees

In order to allow for a distributed implementation of the DFINITY Internet Computer, the order in which the various messages between canisters are delivered and executed is not fully specified.

The  guarantee we do give is that that function calls between two canisters are executed in order, so that a canister who cares about in-order delivery does not have to wait for the response before sending the next message.

More precisely:

 * Method calls between any _two_ canisters are delivered in order, as if they
   were communicating over a single simple FIFO queue.
 * If a WebAssembly function, within a single invocation, makes multiple calls
   to the same canister, they are queued in the order of invocations to `msg.call`.
 * Responses (including replies with `msg.reply`, explicit rejects with `msg.reject` and system-generated error responses) do _not_ have any ordering guarantee relative to each other or to method calls.
 * There is no particular order guarantee for ingress messages submitted via
   the HTTP interface.

WARNING: There is a currently a discrepancy between the
link:../functional{outfilesuffix}[Functional Spec] (calling for all _messages_ to be ordered) and a later design document calling for all _calls_ to be ordered; this may need resolving.

[#interfaces]
== Public Interfaces

[#http-interface]
=== HTTP Interface

You can interact with the DFINITY Computer using a typical HTTP interface.

This document does not explain how to find the location and port of a running DFINITY node. If you use a local node, you can use `http://127.0.0.1:4200/`.

The following API calls are provided, and explained below:
....
/api/request/<request-nonce>/status
/api/canister/new
/api/canister/<canister-id>/<method-name>/call
/api/canister/<canister-id>/<method-name>/query
....


==== Synchronicity across nodes

This documents describes the DFINITY Internet Computer as having a single global state that can be modified and queried. In reality, it consists of many nodes, which may not be perfectly in sync.

As long as you talk to one node only, the observed behavior is nicely sequential. If you issue an update (i.e. state-mutating) call in a canister (e.g. bump a counter), and node A indicates that the call has been executed, and you then issue a read query to node A, then A's response is guaranteed to include the effect of the update call (and you will receive the updated counter value).

If you then (very quickly) issue a read request to node B, it may be that B responds to your read query based on the old state of the canister (and you might receive the old counter value).

The system does not explicitly help with that (e.g. by indicating which particular state a read query is based on, or by allowing the user to request a specific state), as applications have other ways to deal with that issue:

* They can make sure to use a single node, first ask for the status of a update call, and only if that says that the update call has been completed, do the read-only query.
* The application can include sufficient information in the read-only query to tell whether the update call has happened, such as keeping an internal counter of processed messages, or other ways.

[#api-request-status]
==== Polling request status

Path:: `/api/request/<request-nonce>/status`
Method:: `GET`
Response format:: JSON record with these fields:
 * `status`: one of `failed` or `completed`
 * `result`: (if status is `completed`) A result according to the method spec below.
 * `error` (text): (if status is `failed`) An error message

Some API calls below are asynchronous, i.e. the response is not immediately returned to the client. In these cases, a _request nonce_ is returned, and this
request can be used to query its state or fetch the final response.

WARNING: Immediately after issuing a request, this may fail (e.g. return with a “request not found”); it will only succeed when a response (a result or an error) is available.

NOTE: This API call may be extended to indicate when a request has been _inducted_ (e.g. guaranteed to be executed eventually).

NOTE: Request responses will not actually be kept around indefinitely; the policy for when they can be dropped is not defined yet.

[#api-canister-new]
==== Deploying a new canister

Path:: `/api/canister/new`
Method:: `POST`
Payload format:: JSON record with these fields:
 * `module` (blob): A <<canister-module-format,canister module>>
 * `arg` (optional, blob): Initialization arguments
Response format:: JSON record with these fields
 * `request-nonce`: A unique number identifying the request

Uploading a new canister will install this canister, and invoke its `start` system method as explained in Section “<<system-api-start>>“, passing the `arg`, if given, as the method argument.

If the canister does not have a `start` system method, then it is an error to pass a `arg`. If no `arg` is given but a `start` system method is present, an argument of length 0 is assumed.

If the canister installation succeeds, the `result` of <<api-request-status,`/api/request/<request-nonce>/status`>> is a JSON record with this field:

* `canister-id` (64 bit number): ID of the newly created canister

[#api-canister-call]
==== Calling a canister method (update call)

Path:: `/api/canister/<canister-id>/<method-name>/call`
Method:: `POST`
Payload format:: JSON record with these fields:
 * `arg` (blob): Argument to pass to the method

Response format:: JSON record with these fields
 * `request-nonce`: A unique number identifying the request

If the method execution succeeds, the `result` of <<api-request-status,`/api/request/<request-nonce>/status`>> is a blob representing the response of the method call.

[#api-canister-query]
==== Fast-track read-only query call

Path:: `/api/canister/<canister-id>/<method-name>/query`
Method:: `POST`
Payload format:: JSON record with these fields:
 * `arg` (blob): Argument to pass to the method

Response format:: JSON record with these fields
 * `status`: one of `failed` or `completed`
 * `result` (blob): (if status is `completed`) the response of the query
 * `error` (text): (if status is `failed`) An error message

Canister methods that do not change the canister state in a meaningful way can be executed more efficiently. This method provides that ability, and returns the response synchronously.

[#canister-module-format]
=== Canister module format

A canister module is simply a https://webassembly.github.io/spec/core/index.html[WebAssembly module] in binary format (typically `.wasm`).

WARNING: This is a scaffolding spec, close to the current implementation. It will need refinement for features like initialization parameters, dynamically linked libraries. We probably want to go for some zip-file-with-metadata approach.


[#system-api]
=== Canister interface (System API)

The System API is the interface between the running canister and the DFINITY Internet Computer. It allows the WebAssembly module of a canister to expose functionality to the users (method entry points) and the system (e.g. initialization), and exposes system functionality to the canister (e.g. calling other canisters). Because WebAssembly is rather low-level, it also explains how to express higher level concepts (e.g. binary blobs).

[#system-api-module]
==== WebAssembly module requirements

In order for a WebAssembly module to be usable as the code for the canister, it needs to conform to the following requirements:

* If it imports a memory, it must import it from `env.memory`. In the following, “the Wasm memory” refers to this memory.
* If it imports a table, it must import it from `env.table`. In the following, “the Wasm table” refers to this table.
* It may only import functions listed below, at the type given below.
* It may have a `(start)` function. (Note that all system calls will trap when called from `(start)`, as it cannot have a valid `api_nonce`.)
* If it exports a function called `start`, it must have type `+(api_nonce : anyref) -> ()+`.
* If it exports any functions called `dfn_msg <name>` for some `name`, it must have type `+(api_nonce : anyref) -> ()+`.
* No floating point instructions are used in the module. (This may be allowed in the future.)

NOTE: This document assumes that WebAssembly host references can be used (e.g. `anyref`). Until this is so, every `anyref` is replaced with an `i64` that should be treated as opaque by the WebAssembly code.

==== The API nonce

A design goal of the System API is that the canister can restrict which parts of its code can use it. Therefore, all functions exported by the canister have an `api_nonce` parameter, and all invocations of system functions require such a parameter. Because this parameter is a WebAssembly host reference (type `anyref`), it cannot be forged.

[#system-api-messages]
==== Public methods

To define a public method of name `name`, a WebAssembly module exports a function with name `dfn_msg <name>` and type `+(api_nonce : anyref) -> ()+`. We call this the _method entry point_.

NOTE: The space in `dfn_msg <name>` is intentional.

The argument of the call (e.g. the content of the `arg` field in <<api-canister-call,API call to call a canister method>>) is copied into the canister on demand.
In the success callback for a further <<system-api-send,method call>>, the argument refers to the response of that call; in error callbacks, no argument is available. In other words, the lifetime of the argument data is a single WebAssembly function execution, not the whole method call tree.

* `+msg.arg_data_size : (api_nonce : anyref) -> i32+`
+
Size, in bytes, of the argument data.

* `+msg.arg_data_copy : (api_nonce : anyref, dst : i32, length : i32, offset : i32) -> ()+`
+
Copies `length` bytes from `msg_arg[offset..offset+length]` to `memory[dst..dst+length]`, i.e., from the argument data into the Wasm memory.
+
This traps if `offset+length` is greater than the size of the argument data, or if `dst+length` exceeds the size of the Wasm memory, or if called from inside an error callback (see below).

In an error callback, no argument is available, but the error code can be queried:

** `+msg.error_code : (api_nonce : anyref) -> i32+`
+
Returns the error code, if the the current function is invoked as an error callback.
+
It returns the special “no error” code `0` if the it is _not_ invoked as an error callback; this allows canisters to use a single entry point for both the success and error callback, if they choose to do so.

Eventually, the canister will want to respond to the original call, either with success or by signaling an error:

* `+msg.reply : (api_nonce : anyref, offset : i32, length : i32) -> ()+`
+
Replies to the sender with the bytes at `memory[offset..offset+length]`. Traps if `offset+length` exceeds the size of the WebAssembly memory.
+
This function can be called at most once (a second call will trap), and must be called exactly once to indicate success.

* `+msg.reject : (api_nonce : anyref, errcode : i32) -> ()+`
+
Replies to sender with the given error code. The error code must not be 0, otherwise this traps.

If the execution of the function traps for any reason, then all changes to the WebAssembly state, as well as the effect of any externally visible system call (like `msg.reply`, `msg.reject`, `msg.send`), are discarded.

==== System methods

A canister may export a system methods. In contrast to public methods, system methods can only be invoked by the system in special situations (initialization, upgrade). They are exported with an unmangled name (i.e. `start`, not `dfn_msg start`), and it is allowed to have both a system method and public method of the same name. Otherwise, they use the same mechanism for parameter passing and API access.

[#system-api-start]
==== System method: start

If the canister exports a system method called `start`, then this is the first exported WebAssembly function invoked by the system. If an argument was passed along with the actor initialization (see <<api-canister-new>>), it is passed as the argument, otherwise the argument is the empty blob.

The following system calls will trap when called during the execution of `start`: `msg.reply`, `msg.reject`, `msg.call`.

The system assumes the canister to be fully instantiated if the `start` method entry point returns.  If the `start` method entry point traps, then canister installation has failed, and the canister is deleted.

[#system-api-canister-id]
==== Resolving canister ids

To future-proof the System API, references to canisters are represented as abstract WebAssembly references (`anyref`). We provide system functions to convert between the abstract references and their transparent public id, as used by the HTTP interface.

* `+canister.lookup : (api_nonce : anyref, canister_id : i64) -> (canister_ref : anyref)+`
* `+canister.id : (api_nonce : anyref, canister_ref : anyref) -> (canister_id : i64)+`

NOTE: These functions never trap, i.e. they always return a `canister_ref` (resp. a `canister_id`). In a future where not all canisters are publicly addressable by anyone, these conversion functions may become partial. Moreover, while they technically could, these functions do *not* check for the existence of the canister.

[#system-api-send]
==== Sending messages

A canister can do further update calls to other canister. Performing a call is a multi-step process:

1. A canister/method-name pair is turned into an opaque `methodref`.
2. A new call can be created from such a `methodref`, represented by a `callref`.
3. A number of functions can add arguments (data, payments, etc.) to the call.
4. When everything is setup, the canister tells the system to perform the call.

The `methodref` can be used multiple times, it just represents the canister/method-name pair.

The `callref` reference is only valid between `call.create` and `call.perform`, and only within a single WebAssembly function invocation; it cannot be stored or forwarded.

This design is extensible and forward compatible to new call destinations (e.g. new ways to obtain a `methodref` besides just a public canister/method pair), new form of arguments (multiple payments, references) and other settings (gas, expiry times etc.)

* {blank}
+
  method.public : (
    api_nonce    : anyref,
    callee       : anyref, // a canister reference
    name_offset  : i32,    // a pointer to and the length of the
    name_len     : i32,    //   destination’s unmangled method name
  ) -> ( methodref : anyref )
+
Creates a new `methref` from a canister reference and the name of a public method. This function always succeeds. For example, no checking is done if the method actually exists.

* {blank}
+
  call.create : ( methref : anyref ) -> ( callref : anyref )
+
Begins the assembly of a new call, to the given method.
Returns the `callref` that can be filled further on.
This function always succeeds.
* {blank}
+
  call.append_data : (
    callref  : anyref  // the call to extend
    offset   : i32,    // a pointer to and the length of the
    len      : i32,    //   argument to pass to the method
  ) -> ()
+
Copies the data referred to by `offset`/`len` out of the canister and appends it to the (initially empty) data argument of the call.
+
NOTE: This can be invoked multiple times to build up the argument with data from various places on the Wasm heap. This way, the canister does not have to first copy all the pieces from various places into one location.
+
This system call traps if `offset+len` exceeds the size of the WebAssembly memory, or if it is calling during the handling of a <<api-canister-query,read-only query>>.
* {blank}
+
  call.on_reply : (
    callref : anyref  // the call to extend
    fun     : i32,    // funtab entry of type (api : anyref, env : i32) -> ()
    env     : i32,    // an environment to give back to fun
  ) -> ()
+
The system records the current function table entry at the index `fun`. Upon successful completion of the method call, the noted function is executed, and the response data can be queried using `msg.arg_data_size`/`msg.arg_data_copy`.
+
There must be exactly one invocation of `call.on_reply` for each `callref`. (Omitting `call.on_replay` may be allowed later to indicate that the sending canister does not care about receiving the reply.)
* {blank}
+
  call.on_reject : (
    callref : anyref  // the call to extend
    fun     : i32,    // funtab entry of type (api : anyref, env : i32) -> ()
    env     : i32,    // an environment to give back to fun
  ) -> ()
+
The system records the current function table entry at the index `fun`. If the method call fails, the noted function is executed.
+
There must be exactly one invocation of `call.on_reply` for each `callref`. (Omitting `call.on_replay` may be allowed later to indicate that the sending canister wants to ignore the response, or pass it on to its own reject handler.)

* {blank}
+
  call.perform : ( callref : anyref ) -> ()
+
Indicate that the call is ready to be performed. The system queues the call message to the given destination, but does not actually act on in until the current WebAssembly function returns without trapping.
+
After `call.perform`, the `callref` must not be used any more. Invoking any system function with with that callref will trap.
+
If a call is created, but not performed by the time the WebAssembly function ends, it is discarded.


[#system-api-rand]
==== Randomness

With every update method call or response, the system provides fresh unpredictable entropy to the canister. This is cryptographically secure, i.e. neither the caller nor the callee could have had prior knowledge of the value.

* `+msg.get_entropy : (api_nonce : anyref) -> ( i64 )+`
+
Get the random entropy provided with this call. This function is constant during the execution of a single WebAssembly function.
+
During the execution of a read-only query, this function traps. It is up to the canister to know whether it might be currently processing an update call or query call before it should call this function. (A possible extension of this API could be the addition of a `msg.has_entropy` call to check if entropy is available.)



[#public-spec]
== Abstract public behavior

The sections above describe the interface, i.e. outer edges of the DFINITY Internet Computer, but gives only intuitive and rather vague information about what these interfaces actually do.

This section aims to address that question with great precision, by describing the _abstract state_ of the whole DFINITY Internet Computer, and how this state can change in response to API function calls, or spontaneously (modeling asynchronous, distributed or non-deterministic execution).

The design of this abstract specification (e.g. how and where pending messages are stored) are _not_ to be understood to in any way prescribe a concrete implementation or software architecture. The goals here are formal precision and clarity, but not implementability, so this can lead to different ways of phrasing.

=== Notation

We specify the behavior of the system using pseudo-code.

The manipulated values are primitive values (numbers, text, binary blobs), aggregate values (lists, unordered lists a.k.a. bags, partial maps, records with fixed fields, named constructors) and functions.

We use an concatenation operator `·` with various types: To extend sets and maps, or to concatenate lists with lists or lists with elements.

The shape of values is described using a hand-wavy type system.  We use `Foo = Nat` to define type aliases; now `Foo` can be used instead of `Nat`. Often, the right-hand side is a more complex type here, e.g. a record, or multiple possible types separated by a vertical bar (`|`). Partial maps are written as  `Key ↦ Value` and the function type as `Argument -> Result`.

NOTE: All values are immutable! State change is specified by describing the new state, not by changing existing state.

Record fields are accessed using dot-notation (e.g. `S.request_id > 0`). To create a new record from an existing record `R` with some fields changed, the syntax `R where field = new_value` is used. This syntax can also be used to create new records with some deeply nested field changed: `R where some_map[key].field = new_value`.

In the state transitions, upper-case variables (`S`, `C`, `Req_id`) are free variables: The state transition may be followed for any possible value of these variables. `S` always refers to the state of the system before. A state transition often comes with a list of _conditions_, which may restrict the values of these free variables. The _state after_ is usually described using the record update syntax by starting with `S where`.

For example, the condition `S.messages = Older_messages · M · Younger_messages` says that `M` is some message in field `messages` of the record `S`, and that `Younger_messages` and `Older_messages` are the other messages in the system. If the “state after” specifies `S with messages = Older_messages · Younger_messages`, then the message `M` is removed from the state.

=== Abstract state

In this specification, we describe the DFINITY Internet Computer as a state machine. In particular, there is a single piece of data that describes the complete state of the system (called `S` below).

Of course, this is a huge simplification: The real DFINITY Internet Computer is distributed and has a multi-component architecture, and the state is spread over many different components, some physically separated. But this simplification allows us to have a concise description of the system, and to easily make global decisions (such as, “is there any pending message”), without having to specify the bookkeeping that allows such global decision.

==== Identifiers

Canisters and requests are addressed simply by natural numbers; method names can be arbitrary pieces of text:
....
CanId = Nat
ReqId = Nat
MethodName = Text
....

[#abstract-canisters]
==== Abstract canisters

The <<system-api,WebAssembly System API>> is relatively low-level, and some of its details (e.g. that the argument data is queried using separate calls, and that closures are represented by a function pointer and a number, that method names need to be mangled) would clutter this section. Therefore, we abstract over the WebAssembly details as follows:

* The state of a WebAssembly module (memory, tables, globals) is hidden behind an abstract `WasmState`.

* A canister module `CanisterModule` consists of an initial state, and a (pure) function that models function invocation. It either indicates that the canister function traps, or returns a new state together with a description of the invoked asynchronous System API calls.
+
....
WasmState = (abstract)
WasmFunc = (Entropy, WasmState) -> FuncResult
Entropy = NoEntropy | FreshEntropy i64
FuncResult = Trap | Return {
  new_state : WasmState;
  new_calls : List MethodCall;
  response : NoResponse | Response;
}
Response = Reply Blob | Reject ErrCode;
MethodCall = {
  callee : CanId;
  method_name: MethodName;
  arg: Blob;
  callback: Response -> WasmFunc;
}
CanisterModule = {
  init : (Entropy, Blob) -> FuncResult;
  exports : MethodName ↦ (Blob -> WasmFunc)
}
....

Note that `WasmFunc` is an abstract notion of a WebAssembly-state-modifying-function, not merely a concrete function in a WebAssembly module. In particular, it hides the `onreply_env` bookkeeping that we have seen in Section <<system-api>> and can thus model a form of closure, which (currently) do not exist on the WebAssembly level.

A the `Entropy` parameter of a `WasmFunc` is merely passed through to the canister, via the `msg.get_entropy` system call.

The concrete mapping of this abstract `CanisterModule` to actual WebAssembly concepts and the System API is described separately in section <<concrete-canisters>>.

==== Call contexts

The DFINITY Internet Computer provides certain messaging guarantees: If a user or a canister calls another canister, it will eventually get a single response (a reply or a rejection), even if some canister code along the way fails.

To ensure that only one response is generated, and also to detect when no response can be generated any more, we maintain a _call context_. The `replied` field is set to `true` once the call has received a response, further attempts to send a response fail.

....
CallCtxt = {
  canister : CanId;
  caller : CallOrigin;
  replied : bool;
}
CallId = (abstract)
CallOrigin
  = FromUser {
      request : ReqId;
    }
  | FromCanister {
      calling_context : CallId;
      callback: Response -> WasmFunc
    }
....

In this abstract description, call contexts are never garbage collected, even if nothing references them any more; an implementation can do that.

==== Calls and Messages

Calls into and within the DFINITY Internet Computer are implemented as messages passed between canisters. During their lifetime, messages change shape: they begin as a call to a public method, which is resolved to a WebAssembly function that is then executed, potentially generating a response which is then delivered.

Therefore, a message can have different shapes:
....
Queue = Unordered | Queue { from : CanId; to : CanId }
Message
  = CallMessage {
      caller : CallOrigin;
      callee : CanId;
      method_name : Text;
      arg : Blob;
      queue : Queue;
    }
  | FuncMessage {
      call_context : CallId;
      receiver : CanId;
      func : WasmFunc;
      queue : Queue;
    }
  | ResponseMessage {
      call_context : CallId;
      response : Response;
    }
....

The `queue` field is used to describe the message ordering behavior. Its concrete value is only used to determine when the relative order of two messages must be preserved, and not otherwise interpreted. Response messages are not ordered, as explained above, so they have no `queue` field.

A reference implementation would likely maintain a separate list of `messages` for each such queue to efficiently find eligible messages; this document chooses this approach for a simpler and more concise system state.

==== The system state

Finally, we can describe the state of the DFINITY Internet Computer as a record having the following fields:

....
S = {
  requests : ReqId ↦ ReqState;
  user_pubkeys : PublicKey ↦ UserId;
  canisters : CanId ↦ CanState;
  to_register : Bag RegisterRequest;
  to_install : Bag InstallRequest;
  call_contexts : CallId ↦ CallCtxt;
  messages : List Message; // ordered!
}
ReqState
  = Failed { message : Text }
  | Completed { result : Value }
CanState = {
  wasm_state : WasmState;
  module : CanisterModule;
}
InstallRequest = {
  request : ReqId;
  module : CanisterModule;
  arg : Blob;
}
}
....


==== Initial state

The initial state of the system is
....
{
  user_pubkeys = ();
  requests = ();
  canisters = ();
  to_register = ();
  to_install = ();
  calls = ();
  call_contexts = ();
  messages = ();
  responses = ();
}
....
using `()` to denote the empty map or bag.

=== State transitions

Based on this abstract notion of the state, we can describe the behavior of the system.

Some transitions are triggered by invoking the HTTP API; these indicate the HTTP method parameters and response. Other transitions are modeled as spontaneous transitions, and only describe the state before and after.

The state transitions are not complete with regard to error handling. For example, the behavior of sending a message to a non-existent canister is not specified here. For now, we trust our team to make sensible decisions there.

==== New user public key registration (successful)

Procedures for user management, registration of public key, revocation, etc., is not yet defined. We model the registration of a user public key as a spontaneous state transition for now.

Registering public key `PublicKey` to user identity `UserId`

Conditions::
....
    PublicKey ∉ dom S.user_pubkeys
....
State after::
....
S with
    user_pubkeys[PublicKey] = UserId
....

==== User public key deletion (successful)

Deleting public key `PublicKey` associated with identity `UserId`

Conditions::
....
    user_pubkeys[PublicKey] = UserId
....
State after::
....
S with
    PublicKey ∉ dom S.user_pubkeys
....


==== Canister installation request

If a user uploads a new canister module, it is not immediately instantiated, but queued in `S.to_install`.

HTTP request::
`/api/canister/new` with body `{module : <C : CanisterModule>; arg : <A>}`
Conditions::
....
    Req_id ∉ dom S.requests
....
State after::
....
S with
    to_install = { request = Req_id; module = C; arg = A } · S.to_install
....
HTTP response::
A JSON record with `{request-nonce: <Req_id>}`

==== Request status query

The user can query the status of a request. The type of `result`, given as `Value` in the above spec, can vary depending on the request type.

HTTP request::
`/api/requests/<Req_id>/status`
State after::
....
S
....
HTTP response::
A JSON record with
* `{status: failed; message: <msg>}` if `S.requests[Req_id] = Failed { message = msg }`
* `{status: completed; result : <result>}` if `S.requests[Req_id] = Completed { result = result }`

==== Canister installation (successful)

Canister installation turns a canister module into a running canister. This involves invoking the `start` system method (see <<system-api-start>>), which must succeed and must not invoke other methods.

The value `R : i64` is cryptographically randomly chosen.

Conditions::
....
    S.to_install = { request = Req_id; module = C; arg = A } · Other_to_install
    C.init (FreshEntropy R, A) =
      Return { new_state = New_state; new_calls = (); response = NoResponse }
....
State after::
....
S with
    requests[Req_id] = Completed { result = { canister_id = cid } }
    to_install = Other_to_install
    canisters[cid] = { wasm_state = New_state; module = C }
....

==== Canister installation (failing)

Canister installation fails under certain conditions, such a trapping or otherwise misbehaving `start` method:

Conditions::
....
    S.to_install = { request = Req_id; module = C; arg = P } · Other_to_install
    // the conditions of the previous rule do not apply
....
State after::
....
S with
    requests[Req_id] = Failed { message = "Canister installation failed" }
    to_install = Other_to_install
....

An implementation may create a more helpful error message based on why the canister trapped.

==== User message send

Incoming user messages are queued as calls with an `caller` field that ties it to the user's request. We do not make any guarantees about the order of incoming messages.

HTTP request::
`/api/canister/<Cid>/<Meth>/call` with body `{ arg : <Arg> }`
Conditions::
....
    Req_id ∉ dom S.requests
....
State after::
....
S with
    messages =
      CallMessage {
        caller = FromUser { request = Req_id };
        canister = Cid;
        method_name = Meth;
        arg = Arg;
        queue = Unordered;
      } · S.messages
....
HTTP response::
A JSON record with `{request-nonce: <Req_id>}`

==== Call context creation

Before invoking a message to a public entry point, some bookkeeping is required: A call context is created, and the method is looked up in the list of exports.

The position of the message in the queue is unchanged.

Conditions::
....
    S.messages = Older_messages · CallMessage CM · Younger_messages
    F = S.canisters[C.callee].module.exports[M.method_name]
    Ctxt_id ∉ dom S.call_contexts
....
State after::
....
S with
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id;
        receiver = CM.callee;
        func = F(CM.arg)
        queue = CM.queue;
      } ·
      Younger_messages
    call_contexts[Ctxt_id] = {
      canister = C.callee;
      caller = C.caller;
      replied = false;
    }
....

==== Message execution (non-trapping)

We can execute any message that is at the head of its queue, i.e. there is no
older message with the same abstract `queue` field.
The actual message execution, if successful, may enqueue further messages and
-- if the function returns a response -- record this response.
The new call and response messages are enqueued at the end.

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.func (S.canisters[M.receiver].wasm_state) = Ok res
    (res = NoResponse) or (S.call_contexts[M.call_context].replied = false)
....
State after::
....
S with
    canisters[M.receiver].wasm_state = res.new_state;
    messages =
      Older_messages ·
      Younger_messages ·
      [ CallMessage {
          caller = FromCanister {
            call_contexts = M.call_context;
            callback = call.callback
          };
          callee = call.callee;
          method_name = call.method_name;
          arg = call.arg;
          queue = Queue { from = M.receiver; to = call.callee };
        }
      | for call ∈ res.new_calls ] ·
      [ ResponseMessage {
          call_context = M.call_context;
          response = res.response;
        }
      | if res.response ≠ NoResponse ]

     // only if res.response ≠ NoResponse:
     call_contexts[M.call_context].replied = true
....

==== Message execution (trapping)

If a message traps, it gets dropped. No response is generated (some other message may still fulfill this calling context).

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.func(FreshEntropy R, S.canisters[M.receiver].wasm_state) = Trap
....
State after::
....
S with messages = Older_messages · Younger_messages
....

==== Message execution (double response)

If a message tries to respond when its calling context has already be responded to, then we treat it like a trapping message.

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.func(FreshEntropy R, S.canisters[M.receiver].wasm_state) = Ok res
    S.call_contexts[M.call_context].replied = true
    res ≠ NoResponse
....
State after::
....
S with messages = Older_messages · Younger_messages
....

==== Call context starvation

If there is no call, downstream calling context or response that could possibly fulfill a calling context, then an error message is synthesized.

Conditions::
....
    S.call_contexts[Ctxt_id].replied = false
    ∀ CallMessage msg ∈ S.messages. msg.call_context ≠ Ctxt_id
    ∀ ctxt_ids.
        (S.call_contexts[ctxt_ids].replied = false || S.response[ctxt_ids] exists)
	==> S.call_contexts[ctxt_ids].caller.calling_context ≠ Ctxt_id
....
State after::
....
S with
    call_contexts[Ctxt_id].replied = true
    messages =
      S.messages ·
      ResponseMessage {
        call_context = Ctxt_id;
        response = Reject starvation_error_code;
      }
....

==== Callback invocation

When an inter-canister call has been responded to, we can queue the call to the callback.

Conditions::
....
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    S.call_contexts[RM.call_contexts].origin =
      FromCanister {
        call_context = Ctxt_id2
        callback = F
      }
....
State after::
....
S with
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id2
        func = F (RM.response)
        queue = Unordered
      } ·
      Younger_messages
....


==== Respond to user message

When an ingress method call has been responded to, we can record the response in the list of queries.

Conditions::
....
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    S.call_contexts[RM.call_context].origin =
      FromUser { request = Req_id }
....
State after::
....
S with
    messages = Older_messages · Younger_messages
    requests[Req_id]
      | Completed { result = R } if response = Reply R
      | Failed { message = toErrorMessage E } if response = Reject E
....

==== Read-only query call

Ready-only query calls are executed immediately, and without randomness.

HTTP request::
`/api/canister/<Cid>/<Meth>/query` with body `{ arg : <Arg> }`
Conditions::
....
  C = S.canisters[Cid]
  F = C.module.exports[M.method_name]
....
State after::
....
S
....
HTTP response::
* If `F(NoEntropy, Arg) = Trap` then a JSON record with
+
....
{status: failed; error: "Query execution trapped"}
....
* Else if `F(NoEntropy, Arg) = Ok res` and `res.new_calls ≠ ()` then a JSON record with
+
....
{status: failed; error: "Query execution tried to send further messages "}
....
* Else if `F(NoEntropy, Arg) = Ok res` and `res.response = NoResponse` then a JSON record with
+
....
{status: failed; error: "Query execution did not issue a result" }
....
* Else if `F(NoEntropy, Arg) = Ok res` and `res.response = Reject errcode` then a JSON record with
+
....
{status: failed; error: <toErrorMessage errcode> }
....
* Else if `F(NoEntropy, Arg) = Ok res` and `res.response = Reply R` then a JSON record with
+
....
{status: success; result: <R> }
....


[#concrete-canisters]
=== Abstract Canisters to System API

In Section <<abstract-canisters>> we introduced an abstraction over the interface to a canister, to avoid cluttering the abstract specification of the DFINITY Internet Computer from WebAssembly details. In this section, we will fill the gap and explain how the abstract canister interface maps to the <<system-api,concrete System API>> and the WebAssembly concepts as defined in the https://webassembly.github.io/spec/core/index.html[WebAssembly specification].

==== The concrete `WasmState`

The abstract `WasmState` maps to the WebAssembly _store_ `S`, which encompasses the functions, tables, memories and globals of the WebAssembly program.

As explained in Section “<<system-api-module>>”, the WebAssembly module imports at most _one_ memory and at most _one_ table; in the following, _the_ memory (resp. table) and the fields `mem` and `table` of `S` refer to that. Any system call that accesses the memory (resp. table) will trap if the module does not import the memory (resp. table).

We model `mem` as an array of bytes, and `table` as an array of execution functions.

==== The execution state

We can model the execution of WebAssembly functions as stateful functions that have access to the WebAssembly store. In order to also model the behavior of the system imports, which have access to additional data structures, we extend the state as follows:
....
Params = {
  arg : NoArg | Blob;
  errcode : Nat;
}
PartialCall = {
  callee : CanId;
  method : MethodName;
  arg : Blob;
  on_reply : StillMissing;
  on_reply_env : i32;
  on_reject : StillMissing;
  on_reject_env : i32;
  performed : Bool;
}
ExecutionState = {
  wasm_state : S; // a store as per WebAssembly spec
  api_nonce : (abstract)
  params : Params;
  entropy : Entropy;
  response : NoResponse | Response;
  calls : List PartialCall;
  performed_calls : List Call
}
....
This allows us to model WebAssembly functions, including host-provided imports, as functions with implicit mutable access to an `ExecutionState`, dubbed _execution functions_.

Syntactically, we express this using an implicit argument of type `ref ExecutionState` in angle brackets. As syntactic convenience; `x.field := val` describes setting field `field` in the mutable reference `x`. An equivalent formulation using monadic functions in a state monad would be feasible.

==== The concrete `WasmFunc`

We can wrap such an execution function into an abstract `WasmFunc = WasmState -> FuncResult`, e.g. for exports and callbacks, as follows:
....
mkWasmFunc (params : Params, func : <ref ExecutionState>(api_nonce : anyref) -> ()) : WasmFunc =
  λ (entropy, wasm_state) ->
    let es = ref {
      wasm_state = wasm_state;
      api_nonce = fresh_nonce();
      entropy = entropy;
      params = params;
      response = NoResponse;
      calls = ();
    }
    func<es>(api_nonce)
    if this trapped
    then return Trap
    else return (Return {
      new_state = es.wasm_state;
      new_calls = es.performed_calls;
      response = es.response;
    })
....
The lifetime of the `ExecutionState` data structure, and the `api_nonce`, is that one invocation of such a `WasmFunc`.

WARNING: It is nonsensical to pass to a `WasmFunc` a `WasmState` that comes from a different WebAssembly module than the `func` passed to `mkWasmFunc`. The current specification does not do that, because every canister gets instantiated exactly once. Once we add upgrading to this document this needs to be checked.

==== Host references

The System API defines various WebAssembly reference types (`api_nonce`, `canisterref`, `methodref`, `callref`), all passed as a WebAssembly `anyref`. These are opaque to the WebAssembly code, but transparent to our System API. So we model a value of type `anyref` as follows:
....
type anyref
  = APIRef (abstract)
  | CanisterRef CanId
  | MethodRef (CanId, MethodName)
  | CallRef Nat
....

The syntax `let MethodName (c, m) = ref else Trap` indicates that a system functions extracts the values `c` and `m` from a `methodref`, trapping is the reference is not actually a `methodref`. In the future, with the _type import_ WebAssembly proposal, module validation will ensure that these references are not mixed up.

==== System imports

Upon _instantiation_ of the WebAssembly module, we can provide the following executions functions as imports.

....
msg.arg_data_size<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if arg = NoArg then Trap
  return |arg|

msg.arg_data_copy<es>(api_nonce : anyref, dst:i32, length:i32, offset:i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if arg = NoArg then Trap
  if offset+length > |arg| then Trap
  if dst+length > |es.S.mem| then Trap
  es.S.mem[dst..dst+length] := arg[offset..offset+length]

msg.error_code<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  es.error_code

msg.reply<es>(api_nonce : anyref, offset : i32, length : i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  if offset+length > |es.S.mem| then Trap
  es.response := Reply (es.S.mem[offset..offset+length])

msg.reject<es>(api_nonce : anyref, errcode : i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  if errcode = 0 then Trap
  es.response := Reject errcode

canister.lookup<es>(api_nonce : anyref, canister_id : i64) : anyref =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  return canister_id

canister.id<es>(api_nonce : anyref, canister_ref : anyref) : 64 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  return canister_ref

method.public<es>(
  api_nonce    : anyref,
  canister_ref : anyref,
  name_offset  : i32,
  name_len     : i32,
) : ( anyref ) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  let CanisterRef callee = canister_ref else Trap
  if name_offset+name_len > |es.S.mem| then Trap

  return (MethodRef callee es.S.mem[name_offset..name_offset+name_len])

call.create<es>(
  method_ref   : anyref,
) : ( anyref ) =
  let MethodRef callee method_name = method_ref else Trap

  callref := |es.calls|
  es.calls := es.calls ·
   {
      callee = callee;
      method_name = method_name;
      arg = "";
      on_reply = StillMissing;
      on_reply_env = 0;
      on_reject = StillMissing;
      on_reject_env = 0;
      performed = False;
    }
  return callref

call.append_data<es>(callref : anyref, offset : i32, len : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if offset+len > |es.S.mem| then Trap

  es.calls[callidx].arg := es.calls[callidx].arg · es.S.mem[offset..offset+len];

call.on_reply<es>(callref : anyref, fun : i32, env : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if fun > |es.S.table| then Trap
  if typeof(es.S.table[fun]) ≠ func (anyref, i32) -> () then Trap
  if es.calls[callidx].on_reply ≠ StillMissing then Trap

  es.calls[callidx].on_reply := es.S.table[fun]
  es.calls[callidx].on_reply_env := env

call.on_reject<es>(callref : anyref, fun : i32, env : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if fun > |es.S.table| then Trap
  if typeof(es.S.table[fun]) ≠ func (anyref, i32) -> () then Trap
  if es.calls[callidx].on_reject ≠ StillMissing then Trap

  es.calls[callidx].on_reject := es.S.table[fun]
  es.calls[callidx].on_reject_env := env

call.perform<es>(callref : anyref) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if es.calls[callidx].on_reply = StillMissing then Trap
  if es.calls[callidx].on_reject = StillMissing then Trap

  es.calls[callidx].performed := True

  pc := es.calls[callidx]
  es.performed_calls := es.performed_calls ·
    {
      callee = pc.callee;
      method_name = pc.method_name;
      arg = pc.arg;
      callback = λ response -> match response with
        Reply blob -> mkWasmFunc
          ( { arg = blob; errcode = 0 }
          , λ<es'>(api') -> pc.on_reply<es'>(api', pc.onreply_env)
          )
        Reject errcode -> mkWasmFunc
          ( { arg = NoArg; errcode = errcode }
          , λ<es>(api') -> pc.on_reject<es'>(api, pc.onreject_env)
          )
    }

msg.get_entropy<es>(api_nonce : anyref) : i64 =
  if api_nonce ≠ es.api_nonce then Trap
  let (FreshEntropy x) = es.entropy else Trap
  return x
....

==== The concrete `CanisterModule`

Finally we can specify the meaning of an abstract `CanisterModule`:

* The `init` field of the `CanisterModule` is defined as follow:
+
If the WebAssembly module does not export a function called under the name `start`, it is
+
....
λ blob ->
  if |blob| > 0
  then Trap
  else Return {
    new_state = wasm_state;
    new_calls = ();
    response = NoResponse
  }
....
+
Otherwise, if the WebAssembly module exports a function `f` under the name `start`, it is
+
....
λ blob -> match (mkWasmFunc ({ arg = blob; errcode 0 }, f))(wasm_state) with
  Return res when new_calls = () and response = NoResponse -> Return res
  otherwise -> Trap
....
+
where `wasm_state` is the store of the WebAssembly module after _instantiation_ (as per WebAssembly spec) of the WasmModule contained in the <<canister-module-format,canister module>>, including executing a potential `(start)` function.
+
This checks afterwards that the system calls `msg.call` or `msg.reply` were not invoked; an implementation can of course trap already when these system calls have been invoked.

* The partial map `exports` of the `CanisterModule` is defined for all method names `meth` for which the WebAssembly program exports a function `f` named `dfn_msg <meth>`, and has value
+
....
λ blob -> mkWasmFunc ({ arg = blob; errcode 0 }, f)
....

== Discussion and comments

=== User and user key management

We have left it up to the state transition (admin) to assign UserId to public keys. In principle a UserId can be associated with several public keys. A public key on the other hand can map to at most one user. A simpler setting would be a bijection between keys and users, or even to have no user ids at all and just refer to public keys.

Currently the life cycle of a public key is existence or non-existence. A more fine-grained life cycle would be: pre-activation, active, suspended, revoked, deleted. Keys may also have usage constraints e.g. a user may want to have a not-so-secure key with a daily spending cap and very-secure key for high value transactions. And keys may come with activation/expiration times.

It is open whether UserId's are deleted if they have no associated public keys. If they are, there might be overlaps in UserId's over time. This could be avoided by guaranteeing a UserId is only used once, e.g., by incremental numbering (or something else to avoid races for special numbers) or using large random numbers.

As with keys, user ids and user accounts will also be subject to management. Their statuses can be: pre-activation, active, suspended, blacklisted, deleted. There may be usage constraints associated with them, and they may hold public information about a user, e.g., name.

In the future we want explicit interfaces over which a user registers a public key and manage their accounts. One could imagine the user creating an ingress message with new public key, optional existing user id, registration evidence (e.g. signature by existing public key or evidence of PKI certificate), user info (e.g. name or KYC), and signature on everything. Similarly, we would need methods for other types of key management and user management.
