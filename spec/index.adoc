= Public specification of the Internet Computer
Joachim Breitner <joachim@dfinity.org>
:toc2:
:toclevels: 3
:stem: latexmath
:icons: font

== Preamble

This document is work in progress, initially authored by mailto:joachim@dfinity.org[Joachim]. The goal is to have a document that is authoritative, and provides a place and a language to discuss public features of the Internet Computer in a hopefully concrete way. It could also be a document that we can publish to users of the Internet Computer.

Because of its focus on the externally visible behavior of the Internet Computer, it will also help uncover abstraction leaks. Because it aims to describe the full behavior, it helps to show which designs are unexpectedly complicated.

=== Contact

It will be everyone’s shared responsibility to keep this document accurate, but the editor’s responsibility to keep it focused and consistent. If you have additions or corrections, either talk to Joachim in whatever form you prefer, or propose changes to the document directly (but be prepared for editorial rewrites of your text).

=== Status

The documents is currently constantly moving, at a pointer somewhere in the triangle between what is implemented, what is being designed and what is being approved, in a best-effort way.

Please skim the https://github.com/dfinity-lab/dfinity/pulls?q=is%3Apr+is%3Aopen+%22Public+Spec%22+in%3Atitle[list of open PRs] against this document, to get an overview of ongoing discussions.

=== Open questions and missing bits

As we are fleshing out this document, we get comments that we cannot immediately resolve. In order to not drop them, and make it clear to readers which parts are not done yet, we are briefly collecting them here.  (Items marked [MM] are things Mack has committed to take a cut at clarifying functional requirements for by August 19.)

* User IDs: Same question. Do these share the same namespace?
* Missing: Methods without responses/fire-and-forget calls
* To be changed: The System API for calls should be replaced with a more general API that allows canisters to submit API requests.
* Missing: Specifying when responses are deleted.
* Missing: Canister upgrades.
* Missing: Payment and accounts [MM]
* Missing: Gas accounting [MM or Dom]
* Missing: Subnet ids (e.g. modeling multiple HTTP endpoints, multiple accounts, locality requirements of requests) [MM]
* Missing: Time (idea: separate per-canister time, nondeterministic time step transition) [MM]
* Missing: Canister likely need some kind of file store (for IDL specs, static assets, incremental canister module uploads)
* Missing: Storing and retrieving static data (e.g. the Wasm module itself, its IDL spec, HTML assets)
* Missing: Reads may specify a specific (future or past) state
* Missing (optional): References in call arguments and responses? Which references are supported? Can we have `funcrefs`?
* Missing (optional): Certified variables (globals pointing to memory? specially marked read-only methods?)
* Missing (optional): Programmatic canister creation
* Missing (optional): Incremental canister upload for big canister modules.

== Introduction

Welcome to the Internet Computer! We speak of “the” Internet Computer, because although under the hood, a large number of physical computers are working together in non-trivial ways, in the end we have the appearance of a single, shared, secure and world-wide accessible computer. Much, if not all, of the advanced and complex machinery is hidden from those that use the Internet Computer to run their applications and those who use these applications.

=== Scope of this document

This documents describes this external view of the Internet Computer:
Which interfaces it provides to application developers and users, and what will happen when you use these interfaces.

WARNING: While this document describes the public interface and behavior of the Internet Computer, it is not the primary end-user documentation. The creators of the Internet Computer provide further tools, such as the ActorScript programming language, the IDL tooling and the SDK tools, to make programming and using the Internet Computer even more convenient. As an end-user, you might want to start with #TODO#.

If you think of the Internet Computer as a distributed execution engine that _provides_ a WebAssembly-based application hosting service, then this document describes exclusively the latter aspect of it. So to the extent possible, this document will _not_ talk about blockchain, consensus protocols, nodes, subnets and orthogonal persistence. If you want to learn more about the exciting inner workings of the Internet Computer, please consult the link:../index{outfilesuffix}[Component Interface Specifications].

This document tries to be implementation agnostic: If we decide to re-do the implementation of the Internet Computer from scratch at some point in the future, then this document would (ideally) still be valid as is.

This implies that this document does not speak of the interface of the Internet Computer towards its engineers and administrators, as topics like node update, monitoring, logging are inherently tied to the actual _implementation_ and its architecture.


=== Overview of the Internet Computer

If you want to use the Internet Computer as an application developer, you first create a _canister module_ that contains the WebAssembly code and configuration for your application, and deploy it using the <<http-interface,public HTTP interface>>. You can create canisters using the ActorScript language and the SDK (#TODO: Link to SDK docs#), which is more convenient. If you want to use your own tooling, however, then this document describes <<canister-module-format,how a canister module looks like>> and how the <<system-api,WebAssembly code can interact with the system>>.

Once your application is running on the Internet Computer, it is a _canister_, and users can interact with it. They can use the <<http-interface,public HTTP interface>> to interact with the canister according to the <<system-api,System API>>.

The user can also use the HTTP interface to issue read-only queries, which are faster, but cannot change the state of a canister.

.A typical use of the Internet Computer. (This is a simplified view; some of the arrows represent multiple interaction steps or polling.)
[plantuml]
....
actor Developer
actor User
participant "Internet Computer" as IC
participant "Canister 1" as Can1
Developer -> IC : /submit create canister
create Can1
IC -> Can1 : create
Developer <-- IC : canister-id=1
Developer -> IC : /submit install module
IC -> Can1 : initialize
|||
User -> IC : /submit call “hello”
IC -> Can1 : hello
return "Hello world!"
User <-- IC : "Hello World!"
....

Sections “<<http-interface>>” and “<<system-api>>” describe these interfaces, together with a brief description of what they do. Afterwards, you will find a <<public-spec,more formal description>> of the Internet Computer that describes its abstract behavior with high precision.


=== Nomenclature

To get some consistency in this document, we try to use the following terms around method calls and messaging:

The public entry points of canisters are called _methods_. Methods can be declared to be either _update methods_ (state mutation is preserved) or _query methods_ (state mutation is discarded, no further calls can be made).

Methods can be _called_, from _caller_ to _callee_, and will eventually incur a _response_ which is either a _reply_ or a _reject_. A method may have _parameters_, which are provided with concrete _arguments_ in a method call.

Inter-canister calls do not distinguish between update and query calls. External calls can be update calls, which can call both kinds of methods, and query calls, which can _only_ call query methods.

Internally, a call or a response is transmitted as a _message_ from a _sender_ to a _receiver_. Messages do not have a response.

WebAssembly  _functions_ are exported by the WebAssembly module or provided by the System API. These are _invoked_ and can either _trap_ or _return_, possibly with a return value. Functions, too, have parameters and take arguments.

External _users_ interact with the system by issuing _requests_. Requests have responses which can either be replies or rejects. Some requests cause internal messages to be created.

[#requests]
== Requests

External entities (e.g. users) interact with the system by sending a request and receiving responses. This section describes the set of request types provided by the system. The concrete transport, encoding and authentication mechanism via the <<http-interface>>, which is generic for all messages, will be described separately.

=== Submitting requests vs. reading

.The classification of requests, with example request types.
[plantuml]
....
object "API Requests" as request

together {
object "Async" as async {
{field} May change system state
{field} Response via status polling
}

object "Sync" as sync {
{field} Cannot change state
{field} Immediate response
}
}

object "Certified" as certified {
provided by the “system”
}
object "Uncertified" as uncertified {
provided by the “node”
}

together {
 object "Canister installation" as install
 object "Canister update call" as call
 object "Canister query call" as query
 object "Read request status" as status
 object "Read account balance" as balance
}

request <|-- async
request <|-- sync
sync <|-- certified
sync <|-- uncertified

async <|-- install
async <|-- call

uncertified <|-- query
certified <|-- balance
certified <|-- status
....

Certain interactions change the state of the Internet Computer. By the very nature of a distributed implementation, they cannot be acted upon immediately, but only with a delay. Moreover, the actual node that the client talks to may not be honest or, for other reasons, may fail to get the request on the way. This implies the following high-level workflow:

1. A client submits a request via the <<http-interface>>. No useful information is returned from the node (as it would not be trustworthy anyways).
2. For a certain amount of time, the system behaves as if it does not know about the request. (Althought as part of the RPC the receiving endpoint gives an untrusted acknowledgment of receipt or an untrusted declination of the request.)
3. At some point, the system may accept the request for processing (or it expires). From now on, the client can ask any RPC endpoint (for the canister) about the status of the pending request.
4. At some later point, a pending request is acted upon. For some requests this is atomically, for others this involves multiple internal steps.
5. Eventually, a response (indicating success or failure, and possibly carrying data) will be produced, and can be retrieved for a certain amount of time.
6. At the end, the system forgets about the request and its response.

When asking the system about the state or response of a request, the client uses a request id.

Other interactions do not change the state of the system, but only _read_ from it. These may either be untrustworthy, in the sense that a malicious node can make up stuff (e.g. query calls to canisters), or certified, in the sense that the node can prove to the client that this is indeed the system's view of things (e.g. reading request statuses, reading account balances). All these reads go through the `read` RPC endpoint.

We use the term _request_ both for the asynchronous requests that passed to `submit`, as well as for the parameters of a _read_, so that common operations like signing can be done in the same way.


=== Field types

The system supports a number of requests, represented as records, i.e. fields with names and values.

The fields are typed and can have one of these types:

* `u64`: A 64 bit number
* `nat`: A (possibly unbounded) natural number
* `text`: Human readable text (e.g. sequence of Unicode codepoints)
* `blob`: Arbitrary binary data

For readablity, we use the following type synonyms:
....
type EntityId = blob
type CanisterId = EntityId
type UserId = EntityId
....

NOTE: Of course, user ids and canister ids are _not_ just arbitrary binary blobs, but have structure (e.g. “exactly 64 bits long”). But it is possible that any concrete choice will have to be revised or extended later. In order to not break existing code (especially existing canister), the interface uses arbitrary blobs here.

=== Common fields

The following fields are common among all requests:

* `request_type` (`text`): Indicates the type of request, and is one of the values allowed below:

The following fields are common among all _asynchronous_ requests:

* `sender` (`EntityId`): The user who issued the request.
* `expiry`: time(?) until the request must be executed or dropped #TODO: details#
* `nonce` (`blob`, optional): Arbitrary client-provided data, typically randomly generated. This can be used by the client to create distinct requests with otherwise identical fields.

Besides these, every type of request has a different set of request-specific fields.

=== Request types

The following subsections list all supported requests, including their classification (synchronous vs. asynchronous), their request type, the set of fields of the request record and of the reply object and a description of their pupose.


[#api-register-user]
==== User registration

The user registration request will allocate a fresh user id, associate the provided public key with that user, and (not yet specified here) create an empty payment account.

Synchronicity:: asynchronous
Request type:: `create_user`
Request fields::
* `public_key` (`blob`): The public key that can be used to authenticate the user.
Reply fields::
* `user_id` (`UserId`): The user id of the just registered user.

NOTE: Lots of user management requests are still missing, of course, such as adding additional keys, removing keys etc.

[#api-create-canister]
==== Canister registration

Before deploying a canister, the administrator of the canister first has to register  it with the system, to get a canister id (with an empty canister behind it), and then separately install the code.

A canister has a list of _admin users_; initially, the user who has registered the canister is the only admin user.

Synchronicity:: asynchronous
Request type:: `create_canister`
Request fields::
* None
Reply fields::
* `canister_id` (`CanisterId`): The canister id of the just created canister.

Until code is installed, the canister behaves like one with no public methods.

NOTE: This request may later contain specifications of particular features needed from the hosting subnet

[#api-install-code]
==== Canister code installation

After an empty canister has been created via <<api-create-canister>>, the admin can install the first code:

Synchronicity:: asynchronous
Request type:: `install_code`
Request fields::
* `canister_id` (`CanisterId`): The id of the canister to install code for.
* `module` (`blob`): A <<canister-module-format,canister module>>
* `arg` (`blob`): Initialization arguments
Reply fields::
* None

Only a user who is an _admin user_ for the canister can install code.

This will instantiate the canister module and invoke its `canister_init` system method, as explained in Section “<<system-api-init>>”, passing the `arg` to the canister.

If the canister does not have a `canister_init` system method, then `arg` is ignored.

This is atomic: If the response to this request is a `reject`, then this request had no effect. It is an error to invoke `install_code` on a canister again after a previous code installation has succeeded; canister upgrades are handled separately. (This may be relaxed later, in particular if we switch to a non-serializing approach to persistent storage.)

NOTE: This assumes that a canister module fits into a single request. If this assumption turns out to be false, we will provide a more elaborate multi-step interface for code installation. But even then, this simple, atomic way is worth keeping (less error conditions), so we are forward-compatible.

NOTE: Upgrading (i.e. deploying code while preserving state) is a separate request type, not yet described here.

NOTE: Undecided: Should this request also be used to re-install  canister code (i.e. replace the code _without_ preserving the state)? If so, should that intention be made explicit via some field `replace: true` or such?

[#api-update]
==== Canister update call

Synchronicity:: asynchronous
Request type:: `call`
Request fields::
* `canister_id` (`CanisterId`): The id of the canister to call.
* `method_name` (`text`): Name of the canister method to call
* `arg` (`blob`): Argument to pass to the canister method
Reply fields::
* `arg` (`blob`): The blob representing the data replied by the canister.

This request type can _also_ be used to call a query method. A user may choose to go this way, instead of via the likely faster and cheaper <<api-query>> below, if they want to get a _certified_ response.

NOTE: Other arguments besides data (e.g. payments) will be represented in further fields next to `arg`.

[#api-status]
==== Request status

Synchronicity:: synchronous
Request type:: `request-status`
Request fields::
* `request_id` (`blob`): The request id to check the status for, see <<api-request-id>>.
Response fields::
* `status` (`text`): one of `unknown`, `pending`, `replied` or `rejected`
* `reply`: If the status is `replied`, then this member contains the request-type specific reply object (see the specification for the individual request types for which fields exist).
* `reject_code` (`nat`): If the status is `rejected`, then this member contains the reject code (see <<reject-codes>>).
* `reject_message` (`text`): If the status is `rejected`, then this member contains a textual diagnostic message.

The status `pending` is used for requests that have successfully entered the system, known to all nodes, and that are guaranteed to be acted upon eventually.

WARNING: Immediately after submitting a request, this may fail (e.g. return with `unknown`) even though the system is still working on accepting the request as pending.

NOTE: Request responses will not actually be kept around indefinitely, and eventually the status will revert to `unknown`. This will happen no sooner than the request’s expiry time, so that replay attacks are prevented, but likely longer, so that clients have a chance to fetch it. The precise policy is not yet defined.

[#api-query]
==== Canister query call

Canister methods that do not change the canister state in a meaningful way can be executed more efficiently. This method provides that ability, and returns the canister’s response directly within the HTTP response.

Synchronicity:: synchronous
Request type:: `query`
Request fields::
* `canister_id` (`CanisterId`): The id of the canister to query.
* `method_name` (`text`): Name of the canister query method to call
* `arg` (`blob`): Argument to pass to the canister method
Response fields::
* `status` (`text`): One of `replied` or `rejected`
* `reply`: If the status is `replied`, then this member contains the call reply, just as specified in <<api-update>>.
* `reject_code` (`nat`): If the status is `rejected`, then this member contains the reject code (see <<reject-codes>>).
* `reject_message` (`text`): If the status is `rejected`, then this member contains a textual diagnostic message.

//tag::request-id[]
[#api-request-id]
=== Request ids

When querying the status of a request (see <<api-status>>), the user identifies the request using a _request id_. The request id is a simple “object hash” of the request, as described here. The hash operation is always SHA-256.

1. Treat the request type as the value of a text field named `request_type`.
2. Remove the fields that are only used for authentication: `sender_pubkey`, `sender_sig`.
3. For each field that is present in the request (i.e. omitted optional fields are indeed omitted):
   * hash the fields name (in ascii-encoding, without terminal `\x00`) and the value (with the encoding specified below).
4. Sort these by the hash of the field name.
5. Concatenate these hashes, and hash the result.

The resulting hash of 265bits (32 bytes) is the id of the request.

NOTE: The request id is independent of the representation of the request (JSON, CBOR, something else), and does not change if the specification adds further optional field to a request type.

The following encodings of field values are used

* String fields (`request_type`, `method_name`) are encoded in UTF-8, without a terminal `\x00`.
* Binary blobs (`canister-id`, `arg`, `nonce`, `module`) are hashed as they are.
//end::request-id[]

[TIP]
Example calculation (where `H` denotes SHA-256 and `·` denotes blob concatenation):
[source,,options="nowrap"]
----
request_id_of({ request_type: "call", canister_id: 0x00000000000004D2, method_name: "hello", arg: "DIDL\x00\xFD*"})
 = H(concat (sort
   [ H("request_type") · H("call")
   , H("canister_id") · H("\x00\x00\x00\x00\x00\x00\x04\xD2")
   , H("method_name") · H("hello")
   , H("arg") · H("DIDL\x00\xFD*")
   ]))
 = H(concat (sort
   [ 769e6f87bdda39c859642b74ce9763cdd37cb1cd672733e8c54efaa33ab78af9 · 7edb360f06acaef2cc80dba16cf563f199d347db4443da04da0c8173e3f9e4ed
   , 0a3eb2ba16702a387e6321066dd952db7a31f9b5cc92981e0a92dd56802d3df9 · 4d8c47c3c1c837964011441882d745f7e92d10a40cef0520447c63029eafe396
   , 293536232cf9231c86002f4ee293176a0179c002daa9fc24be9bb51acdd642b6 · 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
   , b25f03dedd69be07f356a06fe35c1b0ddc0de77dcd9066c4be0c6bbde14b23ff · 6c0b2ae49718f6995c02ac5700c9c789d7b7862a0d53e6d40a73f1fcd2f70189
   ]))
 = H(concat
   [ 0a3eb2ba16702a387e6321066dd952db7a31f9b5cc92981e0a92dd56802d3df9 · 4d8c47c3c1c837964011441882d745f7e92d10a40cef0520447c63029eafe396
   , 293536232cf9231c86002f4ee293176a0179c002daa9fc24be9bb51acdd642b6 · 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
   , 769e6f87bdda39c859642b74ce9763cdd37cb1cd672733e8c54efaa33ab78af9 · 7edb360f06acaef2cc80dba16cf563f199d347db4443da04da0c8173e3f9e4ed
   , b25f03dedd69be07f356a06fe35c1b0ddc0de77dcd9066c4be0c6bbde14b23ff · 6c0b2ae49718f6995c02ac5700c9c789d7b7862a0d53e6d40a73f1fcd2f70189
   ])
 = 8781291c347db32a9d8c10eb62b710fce5a93be676474c42babc74c51858f94b
----

//tag::reject-codes[]
[#reject-codes]
=== Reject codes

An API request or inter-canister call that is pending in the system will eventually result in either a _reply_ (indicating success, and carrying data) or a _reject_ (indicating an error of some sorts). A reject contains a _rejection code_ that classifies the error and a (hopefully) helpful error message string.

Rejection codes are member of the following enumeration:

* `SYS_FATAL` (1):  Fatal system error, retry unlikely to be useful.
* `SYS_TRANSIENT` (2): Transient system error, retry might be possible.
* `DESTINATION_INVALID` (3): Invalid destination (e.g. canister/account does not exist)
* `CANISTER_REJECT` (4): Explicit reject by the canister.
* `CANISTER_ERROR` (5): Canister error (e.g., trap, no response)

The symbolic names of this enumeration is used throughout this specification, but on all interfaces (HTTPS API, System API), they are represented as positive numbers as given in the list above.

The error message is guaranteed to be a string, i.e. not arbitrary binary data.
//end::reject-codes[]


=== Ordering guarantees

In order to allow for a distributed implementation of the Internet Computer, the order in which the various messages between canisters are delivered and executed is not fully specified.

The  guarantee we do give is that function calls between two canisters are executed in order, so that a canister that requires in-order execution need not wait for the response from an earlier message to a canister before sending a later message to that same canister.

More precisely:

 * Method calls between any _two_ canisters are delivered in order, as if they
   were communicating over a single simple FIFO queue.
 * If a WebAssembly function, within a single invocation, makes multiple calls
   to the same canister, they are queued in the order of invocations to `msg.call`.
 * Responses (including replies with `msg.reply`, explicit rejects with `msg.reject` and system-generated error responses) do _not_ have any ordering guarantee relative to each other or to method calls.
 * There is no particular order guarantee for ingress messages submitted via
   the HTTP interface.

WARNING: There is a currently a discrepancy between the
link:../functional{outfilesuffix}[Functional Spec] (calling for all _messages_ to be ordered) and a later design document calling for all _calls_ to be ordered; this may need resolving.

[#http-interface]
== HTTPS Interface

The concrete mechanism that users use to send requests to the Internet Computer is via an RPC interface, called the _HTTPS API_, which exposes two endpoints to handle the requests as specifed in <<requests>>.

[#api-endpoints]
=== Endpoints

NOTE: This document does not yet explain how to find the location and port of a running Internet Computer Node, nor how to find out which node(s) to talk to for a given canister.

The following API endpoints are provided:
....
/api/v1/submit
/api/v1/read
....

NOTE: Should we add features that _change the state_ but are node-specific (e.g., “restart”), then these would go through a new endpoint like `/api/v1/command`.

For all endpoints, the client performs a POST HTTPS request with `Content-type: application/cbor`. The body is an CBOR value containing the request object.

* The `/api/v1/submit` endpoint accepts the _asynchronous_ requests. Upon successful submission, a (code 202) HTTP response without a body; the user can ues separate `request-status` requests (see <<api-status>>) to determine the response.
* The `/api/v2/read` endpoint accepts the _synchronous__ requests. It returns a response (a CBOR value) as the body of the (code 200) HTTP response.

In both cases case, the usual HTTP errors (e.g. 503) may occur.

NOTE: For some types of synchronous requests (but not all), the node will be able to _prove_ that the overall system agrees on the particular value (e.g. fetching the response from an update call). For which reads, and how this can happen, still needs to be specified.

NOTE: Some or all calls to `/api/v1/read` might have to be paid for using a micro payment scheme (e.g. state-channel) that is to be specified.

// tag::cbor-encoding[]
[#api-cbor]
=== CBOR encoding of requests and responses

Requests and responses are specified here as records with named fields and using suggestive human readable syntax. The actual format in body of the HTTP request or response, however, is https://en.wikipedia.org/wiki/CBOR[CBOR].

Concretely, it consists of a data item with major type 6 (“Semantic tag”) and tag value `55799` (see https://tools.ietf.org/html/rfc7049#section-2.4.5[Self-Describe CBOR]),
followed by a data item with major type 5 (“Map of pairs of data items”), followed by the the fields of the record. The keys are encoded with major type 3 (“Text string”). The values are one of these major types (with more to be added as needed):

* Strings: Major type 3 (“Text string”).
* Blobs: Major type 2 (“Byte string”)
* Integer numbers: Major type 0 or 1 (“Unsigned/signed integer”) if small enough to fit that type, else the https://tools.ietf.org/html/rfc7049#section-2.4.2[Bignum] format is used.
* Nested records: Major type 5 followed by string keys.

As advised by https://tools.ietf.org/html/rfc7049#section-3[section “Creating CBOR-Based Protocols” of the CBOR spec], we clarify that:

* Floating-point numbers may not be used to encode integers.
* Duplicate keys are prohibited in CBOR maps.
// end::cbor-encoding[]


[#request-signatures]
=== Authentication

A request coming in via the HTTP interface needs to be _authenticated_ using a cryptographic signature. To that end, the following two fields are added by the client to the request object:

* `sender_pubkey` (`blob`): Public key used to authenticate this request. Since a user may have more than one key, this field tells the system which key is used.
* `sender_sig` (`blob`): Signature to authenticate this request.

These fields do _not_ contribute to the calculation of the `request_id` (see <<api-request-id>>), because the signature is based on the `request_id`, and because the signatures are not semantically relevant.

The signature scheme used to authenticate users is https://ed25519.cr.yp.to/index.html[*Ed25519*]. In particular:

 * Request fields that indicate public key (`sender_pubkey`, `public_key`) are binary blobs of length 32.
 * Request fields that indicate signatures (`sender_sig`) are binary blobs of length 64.

The `sender_sig` is calculated by signing the 32 byte <<api-request-id, _request id_>> with the secret key that belongs to the public key specified in `public_key`.

NOTE: Information related to gas payments in a user-pays model would also be specified here, as a general mechanism for various request types.

=== Synchronicity across nodes

This documents describes the Internet Computer as having a single global state that can be modified and queried. In reality, it consists of many nodes, which may not be perfectly in sync.

As long as you talk to one (honest) node only, the observed behavior is nicely sequential. If you issue an update (i.e. state-mutating) call to a canister (e.g. bump a counter), and node A indicates that the call has been executed, and you then issue a query call to node A, then A's response is guaranteed to include the effect of the update call (and you will receive the updated counter value).

If you then (quickly) issue a read request to node B, it may be that B responds to your read query based on the old state of the canister (and you might receive the old counter value).

A related problem is that some reads are not certified, and nodes may be dishonest in their response. In that case, the client might want to get more assurance by querying multiple nodes and comparing the result, which is easier if the all queries run against the same state.

Both problems can be solved if read requests can specify the desired state to query, either at-least-this-state (to solve the first problem) or an exactly-this-future-state (to solve the second). This requires some way of identifying states (abstract state counters, timestamps, block heights).

NOTE: Even without this feature, applications can work around these problems. For the first problem, the query result could be such that the client can tell if the query has been received or not. For the second problem, if replies are monotonic in some sense the client can get assurance in their intersection (e.g. if the query returns a list of events that grows over time, then even if different nodes return different lists, the client can get assurance in those events returned by many nodes).


[#canister-module-format]
== Canister module format

A canister module is simply a https://webassembly.github.io/spec/core/index.html[WebAssembly module] in binary format (typically `.wasm`).

WARNING: This is a scaffolding spec, close to the current implementation. It will need refinement for features like initialization parameters, dynamically linked libraries. We probably want to go for some zip-file-with-metadata approach.


[#system-api]
== Canister interface (System API)

The System API is the interface between the running canister and the Internet Computer. It allows the WebAssembly module of a canister to expose functionality to the users (method entry points) and the system (e.g. initialization), and exposes system functionality to the canister (e.g. calling other canisters). Because WebAssembly is rather low-level, it also explains how to express higher level concepts (e.g. binary blobs).

[#system-api-module]
=== WebAssembly module requirements

In order for a WebAssembly module to be usable as the code for the canister, it needs to conform to the following requirements:

* If it imports a memory, it must import it from `env.memory`. In the following, “the Wasm memory” refers to this memory.
* If it imports a table, it must import it from `env.table`. In the following, “the Wasm table” refers to this table.
* It may only import functions listed below, at the type given below.
* It may have a `(start)` function. (Note that by construction, system calls that require a valid `api_nonce` will trap when called from `(start)`.)
* If it exports a function called `canister_init`, the function must have type `+(api_nonce : anyref) -> ()+`.
* If it exports any functions called `canister_update <name>` or `canister_query <name>` for some `name`, the functions must have type `+(api_nonce : anyref) -> ()+`.
* It may not export both `canister_update <name>` and `canister_query <name>` with the same `name`.
* No floating point instructions are used in the module. (This may be allowed in the future.)
* No floating point local or global variables are used in the module. (This may be allowed in the future.)

NOTE: This document assumes that WebAssembly host references can be used (e.g. `anyref`). Until this is so, every `anyref` is replaced with an `i64` that should be treated as opaque by the WebAssembly code.

=== Interpretation of numbers

WebAssembly number types (`i32`, `i64`) do not indicate if the numbers are to be interpreted as signed or unsigned. Unless noted otherwise, whenever the System API interprets them as numbers (e.g. memory pointers, buffer offsets, array lengths), they are to be interpreted as unsigned.

=== The API nonce

A design goal of the System API is that the canister can restrict which parts of its code can use it. Therefore, all functions exported by the canister have an `api_nonce` parameter, and all invocations of system functions require such a parameter. Because this parameter is a WebAssembly host reference (type `anyref`), it cannot be forged.

[#system-api-requests]
=== Public methods

To define a public method of name `name`, a WebAssembly module exports a function with name `canister_update <name>` or `canister_query <name>` and type `+(api_nonce : anyref) -> ()+`. We call this the _method entry point_. The name of the exported function distinguishes update and query methods.

NOTE: The space in `canister_update <name>` resp. `canister_query <name>` is intentional.

The argument of the call (e.g. the content of the `arg` field in the <<api-update,API request to call a canister method>>) is copied into the canister on demand.
In the reply callback for a further <<system-api-call,method call>>, the argument refers to the response of that call; in reject callbacks, no argument is available. In other words, the lifetime of the argument data is a single WebAssembly function execution, not the whole method call tree.

* `+msg.arg_data_size : (api_nonce : anyref) -> i32+`
+
Size, in bytes, of the argument data.
+
This traps if there is no argument data is available (e.g. in a reply callback).

* `+msg.arg_data_copy : (api_nonce : anyref, dst : i32, offset : i32, length : i32) -> ()+`
+
Copies `length` bytes from `msg_arg[offset..offset+length]` to `memory[dst..dst+length]`, i.e., from the argument data into the Wasm memory.
+
This traps if `offset+length` is greater than the size of the argument data, or if `dst+length` exceeds the size of the Wasm memory, or if called from inside a reject callback (see below).

In a reject callback, no argument is available, but the reject code can be queried:

** `+msg.reject_code : (api_nonce : anyref) -> i32+`
+
Returns the reject code, if the current function is invoked as a reject callback.
+
It returns the special “no error” code `0` if the callback is _not_ invoked as a reject callback; this allows canisters to use a single entry point for both the reply and reject callback, if they choose to do so.
+
** `+msg.reject_msg_len : (api_nonce : anyref) -> i32+`
+
Returns the length of the reject message, in bytes. Traps if this is not invoked from a reject callback.
** `+msg.reject_msg_copy : (api_nonce : anyref, dst : i32, offset : i32, length : i32) -> ()+`
+
Copies `length` bytes from `reject_msg[offset..offset+length]` to `memory[dst..dst+length]`.
+
This traps if `offset+length` is greater than the size of the reject message, or if `dst+length` exceeds the size of the Wasm memory, or if not called from inside a reject callback.


Eventually, the canister will want to respond to the original call, either by replying (indicating success) or rejecting (signalling an error):

* `+msg.reply_data_append : (api_nonce : anyref, src : i32, length : i32) -> ()+`
+
Copies the data referred to by `src`/`length` out of the canister and appends it to the (initially empty) data reply.
+
NOTE: This can be invoked multiple times to build up the argument with data from various places on the Wasm heap. This way, the canister does not have to first copy all the pieces from various places into one location.
+
This system call traps if `src+len` exceeds the size of the WebAssembly memory, or if the current call already has been responded to.

* `+msg.reply : (api_nonce : anyref) -> ()+`
+
Replies to the sender with the data assembled using `msg.reply_data_append`.
+
This function can be called at most once (a second call will trap), and must be called exactly once to indicate success.

* `+msg.reject : (api_nonce : anyref, src : i32, length : i32) -> ()+`
+
Rejects the call. The data referred to by `src`/`length` is used for the diagnostic message.
+
This system call traps if `src+len` exceeds the size of the WebAssembly memory, or if the current call already has been responded to, or if the data referred to by `src`/`length` is not valid UTF8.
+
Possible reply data assembled using `msg.reply_data_append` is discarded.

If the execution of the function traps for any reason, then all changes to the WebAssembly state, as well as the effect of any externally visible system call (like `msg.reply`, `msg.reject`, `call.invoke`), are discarded.

=== System methods

A canister may export a system method. In contrast to public methods, system methods can only be invoked by the system in special situations (initialization, upgrade). They are exported with an unmangled name (i.e. `canister_init`, not `canister_update init`), and it is allowed to have both a system method and public method of the same name. Otherwise, they use the same mechanism for parameter passing and API access.

[#system-api-init]
=== System method: canister_init

If the canister exports a system method called `canister_init`, then this is the first exported WebAssembly function invoked by the system. The argument that was passed along with the canister initialization request (see <<api-install-code>>) is available to the canister via `msg.arg_data_size/copy`.

The following system calls will trap when called during the execution of `canister_init`: `msg.reply`, `msg.reply_data_append`, `msg.reject`, `call.create`.

The system assumes the canister to be fully instantiated if the `canister_init` method entry point returns.  If the `canister_init` method entry point traps, then canister installation has failed, and the canister is deleted.

[#system-api-canister-id]
=== Resolving canister ids

To future-proof the System API, references to canisters are represented as abstract WebAssembly references (`anyref`). We provide system functions to convert between the abstract references (the `anyref`) and their transparent public id (the `blob`, represented by a pointer/length pair).

* `+canister.id_valid : (api_nonce : anyref, canister_id_src : i32, canister_id_len : i32) -> i32+`
* `+canister.id_lookup : (api_nonce : anyref, canister_id_src : i32, canister_id_len : i32) -> (canister_ref : anyref)+`
* `+canister.id_len : (api_nonce : anyref, canister_ref : anyref) -> i32+`
* `+canister.id_copy : (api_nonce : anyref, canister_ref : anyref, dst: i32) -> ()+`

The `canister.id_valid` function returns `1` if the canister id is syntactically valid (e.g.: exactly 8 bytes long if we are using 64 bit canister ids) and `0` otherwise. It does not check whether there exists a canister with that id (as that might not be locally possible)

The `canister.id_lookup` function traps if the the canister id is not valid. As usually, all these function trap if they would read or write canister memory out of bounds.

Furthermore, a canister can learn about its own identity:

 * `+canister.self : (api_nonce : anyref) -> (canister_ref : anyref)+`


[#system-api-call]
=== Inter-canister method calls

When handling a call, a canister can do further calls to another canister. Performing a call is a multi-step process:

1. A canister/method-name pair is turned into an opaque `methodref`.
2. A new call can be created from such a `methodref`, represented by a `callref`.
3. A number of functions can add arguments (data, payments, etc.) to the call.
4. When everything is setup, the canister tells the system to perform the call.

The `methodref` can be used multiple times, it just represents the canister/method-name pair.

The `callref` reference is only valid between `call.create` and `call.perform`, and only within a single WebAssembly function invocation; it cannot be stored or forwarded.

This design is extensible and forward compatible to new call destinations (e.g. new ways to obtain a `methodref` besides just a public canister/method pair), new form of arguments (multiple payments, references) and other settings (gas, expiry times etc.)

This API is _not_ available from the canister initialization function, nor from the handler of an _update_ method.

* {blank}
+
  method.public : (
    api_nonce : anyref,
    callee    : anyref, // a canister reference
    name_src  : i32,    // a pointer to and the length of the
    name_len  : i32,    //   destination’s unmangled method name
  ) -> ( methodref : anyref )
+
Creates a new `methodref` from a canister reference and the name of a public method. This function always succeeds. For example, no checking is done if the method actually exists.

* {blank}
+
  call.create : ( methodref : anyref ) -> ( callref : anyref )
+
Begins the assembly of a new call, to the given method.
Returns the `callref` that can be filled further on.
+
This system call traps if it is calling during the handling of a <<api-query,query call>>.
* {blank}
+
  call.arg_data_append : (
    callref : anyref  // the call to extend
    src     : i32,    // a pointer to and the length of the
    len     : i32,    //   argument to pass to the method
  ) -> ()
+
Copies the data referred to by `src`/`len` out of the canister and appends it to the (initially empty) data argument of the call.
+
NOTE: This can be invoked multiple times to build up the argument with data from various places on the Wasm heap. This way, the canister does not have to first copy all the pieces from various places into one location.
+
This system call traps if `src+len` exceeds the size of the WebAssembly memory.
* {blank}
+
  call.on_reply : (
    callref : anyref  // the call to extend
    fun     : i32,    // funtab entry of type (api : anyref, env : i32) -> ()
    env     : i32,    // an environment to give back to fun
  ) -> ()
+
The system records the current function table entry at the index `fun`. Upon successful completion of the method call, the noted function is executed, and the response data can be queried using `msg.arg_data_size`/`msg.arg_data_copy`.
+
There must be exactly one invocation of `call.on_reply` for each `callref`. (Omitting `call.on_reply` may be allowed later to indicate that the sending canister does not care about receiving the reply.)
* {blank}
+
  call.on_reject : (
    callref : anyref  // the call to extend
    fun     : i32,    // funtab entry of type (api : anyref, env : i32) -> ()
    env     : i32,    // an environment to give back to fun
  ) -> ()
+
The system records the current function table entry at the index `fun`. If the method call fails, the noted function is executed.
+
There must be exactly one invocation of `call.on_reject` for each `callref`. (Omitting `call.on_reject` may be allowed later to indicate that the sending canister wants to ignore the response, or pass it on to its own reject handler.)

* {blank}
+
  call.perform : ( callref : anyref ) -> ()
+
Indicate that the call is ready to be performed. The system queues the call message to the given destination, but does not actually act on in until the current WebAssembly function returns without trapping.
+
After `call.perform`, the `callref` must not be used any more. Invoking any system function with that callref will trap.
+
If a call is created, but not performed by the time the WebAssembly function ends, it is discarded.

NOTE: The `call.`-prefixed system functions do not require an 'api_nonce', only the construction of the `methodref` passed to `call.create` does.
This API design supports delegating the initialization of a given `callref` to less trusted code, without granting that code full access to the API via an `api_nonce`.

=== Debugging aids

During local development and execution on a local network, the canister needs a way to emit textual trace messages. On the “real” network, these do not do anything.

NOTE: This system call is intentionally not guarded by an `api_nonce`, so that one can do Printf-like debugging of code that otherwise is not allowed to issue system calls without having to refactor the code first.

* `+debug.print : (src : i32, len : i32) -> ()+`
+
When executing in an environment that supports debugging, this copies out the data specified by `src` and `len`, and logs, prints or stores it in an environment-appropriate way. The copied data may likely be a valid string in UTF8-encoding, but the environment should be prepared to handle binary data (e.g. by printing it in escaped form).
+
Semantically, this function is always a no-op, and never traps, even if the `src+len` exceeds the size of the memory, or if this function is executed from `(start)`. If the environment cannot perform the print, it just skips it.

NOTE: We may at some point require modules deployed to the real network to not even import this function.

Similarly, the system allows the canister to effectively trap, but give some indication about why it trapped:

* `+debug.trap : (src : i32, len : i32) -> ()+`
+
This function always traps.
+
The environment may copy out the data specified by `src` and `len`, and log, print or store it in an environment-appropriate way, or include it in system-generated reject messages where appropriate. The copied data may likely be a valid string in UTF8-encoding, but the environment should be prepared to handle binary data (e.g. by printing it in escaped form).


[#public-spec]
== Abstract public behavior

The sections above describe the interface, i.e. outer edges of the Internet Computer, but gives only intuitive and rather vague information about what these interfaces actually do.

This section aims to address that question with great precision, by describing the _abstract state_ of the whole Internet Computer, and how this state can change in response to API function calls, or spontaneously (modeling asynchronous, distributed or non-deterministic execution).

The design of this abstract specification (e.g. how and where pending messages are stored) are _not_ to be understood to in any way prescribe a concrete implementation or software architecture. The goals here are formal precision and clarity, but not implementability, so this can lead to different ways of phrasing.

=== Notation

We specify the behavior of the system using pseudo-code.

The manipulated values are primitive values (numbers, text, binary blobs), aggregate values (lists, unordered lists a.k.a. bags, partial maps, records with fixed fields, named constructors) and functions.

We use an concatenation operator `·` with various types: to extend sets and maps, or to concatenate lists with lists or lists with elements.

The shape of values is described using a hand-wavy type system.  We use `Foo = Nat` to define type aliases; now `Foo` can be used instead of `Nat`. Often, the right-hand side is a more complex type here, e.g. a record, or multiple possible types separated by a vertical bar (`|`). Partial maps are written as  `Key ↦ Value` and the function type as `Argument -> Result`.

NOTE: All values are immutable! State change is specified by describing the new state, not by changing existing state.

Record fields are accessed using dot-notation (e.g. `S.request_id > 0`). To create a new record from an existing record `R` with some fields changed, the syntax `R where field = new_value` is used. This syntax can also be used to create new records with some deeply nested field changed: `R where some_map[key].field = new_value`.

In the state transitions, upper-case variables (`S`, `C`, `Req_id`) are free variables: The state transition may be followed for any possible value of these variables. `S` always refers to the state of the system before. A state transition often comes with a list of _conditions_, which may restrict the values of these free variables. The _state after_ is usually described using the record update syntax by starting with `S where`.

For example, the condition `S.messages = Older_messages · M · Younger_messages` says that `M` is some message in field `messages` of the record `S`, and that `Younger_messages` and `Older_messages` are the other messages in the system. If the “state after” specifies `S with messages = Older_messages · Younger_messages`, then the message `M` is removed from the state.

=== Abstract state

In this specification, we describe the Internet Computer as a state machine. In particular, there is a single piece of data that describes the complete state of the system (called `S` below).

Of course, this is a huge simplification: The real Internet Computer is distributed and has a multi-component architecture, and the state is spread over many different components, some physically separated. But this simplification allows us to have a concise description of the system, and to easily make global decisions (such as, “is there any pending message”), without having to specify the bookkeeping that allows such global decision.

==== Identifiers

Canisters and users are (abstractly) simply blobs, even if the implementation uses only a subset of possible blobs (e.g. 64 bit numbers).
Method names can be arbitrary pieces of text:
....
CanId = Blob
UserId = Blob
MethodName = Text
....

The system keeps `CanId` and `UserId` disjoint.

Not all blobs are valid identifiers, but this specification is abstract in the precise form of syntactic validation. We merely assume a function that checks validity:
....
is_valid_id : Blob -> Bool
....


[#abstract-canisters]
==== Abstract canisters

The <<system-api,WebAssembly System API>> is relatively low-level, and some of its details (e.g. that the argument data is queried using separate calls, and that closures are represented by a function pointer and a number, that method names need to be mangled) would clutter this section. Therefore, we abstract over the WebAssembly details as follows:

* The state of a WebAssembly module (memory, tables, globals) is hidden behind an abstract `WasmState`.

* A canister module `CanisterModule` consists of an initial state, and a (pure) function that models function invocation. It either indicates that the canister function traps, or returns a new state together with a description of the invoked asynchronous System API calls.
+
....
WasmState = (abstract)

RejectCode = Nat
Response = Reply Blob | Reject (RejectCode, Text)
MethodCall = {
  callee : CanId;
  method_name: MethodName;
  arg: Blob;
  callback: Response -> UpdateFunc;
}

InitFunc = (CanId, Blob) -> Trap | Return WasmState
UpdateFunc = (CanId, WasmState) -> Trap | Return {
  new_state : WasmState;
  new_calls : List MethodCall;
  response : NoResponse | Response;
}
QueryFunc = (CanId, WasmState) -> Trap | Return Response


CanisterModule = {
  init : InitFunc
  update_methods : MethodName ↦ (Blob -> UpdateFunc)
  query_methods : MethodName ↦ (Blob -> QueryFunc)
}
....

This high-level interface presents a pure, mathematical model of a canister, and hides the bookkeeping required to provide the System API as seen in Section <<system-api>>.

Parameters like `CanId` are merely passed through to the canister, via the `canister.self` system calls.

The concrete mapping of this abstract `CanisterModule` to actual WebAssembly concepts and the System API is described separately in section <<concrete-canisters>>.

==== Call contexts

The Internet Computer provides certain messaging guarantees: If a user or a canister calls another canister, it will eventually get a single response (a reply or a rejection), even if some canister code along the way fails.

To ensure that only one response is generated, and also to detect when no response can be generated any more, we maintain a _call context_. The `replied` field is set to `true` once the call has received a response, further attempts to send a response fail.

....
CallCtxt = {
  canister : CanId;
  caller : CallOrigin;
  replied : bool;
}
CallId = (abstract)
CallOrigin
  = FromUser {
      request : Request;
    }
  | FromCanister {
      calling_context : CallId;
      callback: Response -> WasmFunc
    }
....

In this abstract description, call contexts are never garbage collected, even if nothing references them any more; an implementation can do that.

==== Calls and Messages

Calls into and within the Internet Computer are implemented as messages passed between canisters. During their lifetime, messages change shape: they begin as a call to a public method, which is resolved to a WebAssembly function that is then executed, potentially generating a response which is then delivered.

Therefore, a message can have different shapes:
....
Queue = Unordered | Queue { from : CanId; to : CanId }
Message
  = CallMessage {
      caller : CallOrigin;
      callee : CanId;
      method_name : Text;
      arg : Blob;
      queue : Queue;
    }
  | FuncMessage {
      call_context : CallId;
      receiver : CanId;
      func : UpdateFunc;
      queue : Queue;
    }
  | ResponseMessage {
      call_context : CallId;
      response : Response;
    }
....

The `queue` field is used to describe the message ordering behavior. Its concrete value is only used to determine when the relative order of two messages must be preserved, and not otherwise interpreted. Response messages are not ordered, as explained above, so they have no `queue` field.

Although the `func` field of `FuncMessage` has type `UpdateFunc`, it could also be a query call. We will see below that an `QueryFunc` can be modeled as an `UpdateFunc`.

A reference implementation would likely maintain a separate list of `messages` for each such queue to efficiently find eligible messages; this document chooses this approach for a simpler and more concise system state.

==== API requests

We distinguish between the _asynchronous_ API requests passed to `/api/v1/submit`, which may be present in the system state, and the _synchronous_ API requests passed to `/api/v1/read`, which are only ephemeral.

The `sender` field is always the id of the user who submits the message, and is authenticated (once we have defined signatures).

....
Request
  = RegisterCanister = {
    nonce : Blob;
    sender : UserId;
    sender_pubkey : PublicKey;
    sender_sig : Signature;
  }
  | RegisterUser = {
    nonce : Blob;
    sender : UserId;
    sender_pubkey : PublicKey;
    sender_sig : Signature;
    public_key : PublicKey;
  }
  | InstallCode = {
    nonce : Blob;
    sender : UserId;
    sender_pubkey : PublicKey;
    sender_sig : Signature;
    canister_id :  CanId;
    module : CanisterModule;
    arg : Blob;
  }
  | CanisterUpdateCall = {
    nonce : Blob;
    sender : UserId;
    sender_pubkey : PublicKey;
    sender_sig : Signature;
    callee : CanId;
    method_name : Text;
    arg : Blob;
  }
....

The evolution of an `Request` goes through these states:
....
RequestStatus
  = Accepted
  | Processing
  | Failed (RejectCode, Text)
  | Completed { result : Value }
....

The transitions are the following:

[plantuml]
....
(*) --> "Client creates message" #DDDDDD
   --> "Submitted" #DDDDDD
   --> "Accepted"
   --> "Processing"
if "" then
  --> "Completed"
  --> "Expired" #DDDDDD
  else
  --> "Failed"
  --> "Expired" #DDDDDD
  "Accepted" --> "Completed"
  "Accepted" --> "Failed"
endif
....

Note that all gray states are _not_ represented in the system state, and are indistinguishable from “message does not exist”. In order to avoid replay-attacks, messages have a limited validity, and the last transition (forgetting the message) must happen after the message’s expiry field invalidates it.

The states `Accepted` and `Processing` are for internal bookkeeping, both are presented as “Pending” to the user. The processing state may be skipped for certain messages.


These are the synchronous read messages:

....
APIReadRequest
  = ReadStatus = {
    request_id : Request
  }
  | CanisterQuery = {
    callee : CanId;
    method_name : Text;
    arg : Blob;
  }
....

A `ReadStatus` refers to a request by way of a _request id_, which is a hash of the request content:
....
Request = Blob
request_id_of : Request -> Request
....

The precise algorithm to calculate this request id is specified in <<api-request-id>>.


For the signatures in an `Request`, we assume that the following function implements https://ed25519.cr.yp.to/index.html[*Ed25519*].
....
PublicKey = Blob
Signature = Blob
verify_signature : PublicKey -> Signature -> Blob -> Bool
....

==== The system state

Finally, we can describe the state of the Internet Computer as a record having the following fields:

....
S = {
  requests : Request ↦ RequestStatus ;
  users : UserId ↦ UserData;
  canisters : CanId ↦ CanState;
  admins : CanId ↦ Set UserId;
  call_contexts : CallId ↦ CallCtxt;
  messages : List Message; // ordered!
}
CanState = EmptyCanister | {
  wasm_state : WasmState;
  module : CanisterModule;
}
UserData = {
  public_keys : Set PublicKey
}
....

==== Initial state

The initial state of the system is
....
{
  requests = ();
  users = ();
  canisters = ();
  admins = ();
  call_contexts = ();
  messages = ();
}
....
using `()` to denote the empty map or bag.

=== State transitions

Based on this abstract notion of the state, we can describe the behavior of the system. There are three classes of behaviors:

 * Asynchronous API requests that are submitted via `/api/v1/read`. These transitions describes checks that the request must pass to be accepted.
 * Spontaneous transitions that model the internal behavior of the system, by describing conditions on the state that allow the transition to happen, and the state after.
 * Responses to reads (i.e. `/api/v1/read`). By definition, these do _not_ change the state of the system, and merely describe the response based on the read request and the current system state.

The state transitions are not complete with regard to error handling. For example, the behavior of sending a request to a non-existent canister is not specified here. For now, we trust our team to make sensible decisions there.

==== API Request submission

After a node accepts a request via `/api/v1/submit`, it gets added to the system in the `Accepted` state.

This may only happen if the following validation steps pass:

 * The signature on the request is valid.
 * The key used to sign the request is among the sending user’s public keys.

More validation (e.g. authorization) steps may be added here.

Submitted request:: `M`
Conditions::
....
    M.sender_pubkey ∈ S.users[M.sender].public_keys
    verify_signature M.sender_pubkey M.sender_sig (request_id_of M) = true
....
State after::
....
S with
    requests[M] = Accepted
....

NOTE: This is not instantaneous (the system takes some time to agree it accepts the request) nor guaranteed (a node could just drop the request, or maybe it did not pass validation). But once it has entered the system like this, it will be acted upon.

NOTE: Due to this check, the `sender` field of any request in the system state is authenticated, so an implementation may actually drop the `sender_sig` field at this point.

==== User registration

A user registration request has the effect of allocating a fresh user id:

Conditions::
....
    S.requests[RegisterUser M] = Accepted
    is_valid_id UserId = true
    UserId ∉ (dom S.users ∪ dom S.canisters)
....
State after::
....
S with
    requests[RegisterUser M] = Completed { result = { user_id = UserId } }
    users[UserId] = {
      public_keys = { M.public_key }
    }
....

==== Canister registration

A Canister registration request has the effect of allocating a fresh canister id:

Conditions::
....
    S.requests[RegisterCanister M] = Accepted
    is_valid_id CanId = true
    CanId ∉ (dom S.users ∪ dom S.canisters)
....
State after::
....
S with
    requests[RegisterCanister M] = Completed { result = { canister_id = CanId } }
    canisters[CanId] = EmptyCanister
....

==== Canister code installation

Only an admin of the given canister can install new code. This turns an empty canister into a running canister. This involves invoking the `canister_init` system method (see <<system-api-init>>), which must succeed and must not invoke other methods.

Conditions::
....
    S.requests[InstallCode M] = Accepted
    S.canisters[M.canister_id] = EmptyCanister
    M.sender ∈ S.admins[M.canister_id]
    M.module.init (M.arg) =
      Return { new_state = New_state; new_calls = (); response = NoResponse }
....
State after::
....
S with
    requests[InstallCode M] = Completed { result = { } }
    canisters[M.canister_id] = { wasm_state = New_state; module = M.module }
....

==== Initiating canister calls

A first step in processing a canister update call is to create a `CallMessage` in the message queue.

The `request` field of the `FromUser` caller establishes the connection to the api message. One could use the corresponding `request_id_of` for this purpose, but this formulation is more abstract.

We do not make any guarantees about the order of incoming messages.

Conditions::
....
    S.requests[CanisterUpdateCall M] = Accepted
....
State after::
....
S with
    requests[CanisterUpdateCall M] = Processing
    messages =
      CallMessage {
        caller = FromUser { request = CanisterUpdateCall M };
        callee = M.callee;
        method_name = M.method_name;
        arg = M.arg;
        queue = Unordered;
      } · S.messages
....

==== Call context creation

Before invoking a message to a public entry point, some bookkeeping is required: A call context is created, and the method is looked up in the list of exports. This happens for both ingress and inter-canister messages.

The position of the message in the queue is unchanged.

Conditions::
....
    S.messages = Older_messages · CallMessage CM · Younger_messages
    S.canisters[CM.callee] ≠ EmptyCanister
    M = S.canisters[CM.callee].module
    F = if M.method_name ∈ M.update_methods
        then M.update_methods[CM.method_name]
        else query_to_update_func (M.query_methods[CM.method_name])
    Ctxt_id ∉ dom S.call_contexts
....
State after::
....
S with
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id;
        receiver = CM.callee;
        func = F (CM.arg)
        queue = CM.queue;
      } ·
      Younger_messages
    call_contexts[Ctxt_id] = {
      canister = CM.callee;
      caller = CM.caller;
      replied = false;
    }
....

The function `query_to_update_func` simply turns a query function into an update function, this is merely a notational trick to simplify the message execution rules:
....
query_to_update_func f =
  λ blob → λ (self_id, wasm_state) →
    match f(blob)(self_id, wasm_state) with
      Trap → Trap
      Return res → Return {
        new_state = wasm_state;
        new_calls = [];
        response = res;
      }
....
Note that by construction, a query function will either trap or return with a response; it will never send calls, and it will never change the state of the canister.

==== Message execution (non-trapping)

We can execute any message that is at the head of its queue, i.e. there is no
older message with the same abstract `queue` field.
The actual message execution, if successful, may enqueue further messages and
-- if the function returns a response -- record this response.
The new call and response messages are enqueued at the end.

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    S.canisters[C.callee] ≠ EmptyCanister
    M.func(M.receiver, S.canisters[M.receiver].wasm_state) = Return res
    (res.response = NoResponse) or (S.call_contexts[M.call_context].replied = false)
....
State after::
....
S with
    canisters[M.receiver].wasm_state = res.new_state;
    messages =
      Older_messages ·
      Younger_messages ·
      [ CallMessage {
          caller = FromCanister {
            call_context = M.call_context;
            callback = call.callback
          };
          callee = call.callee;
          method_name = call.method_name;
          arg = call.arg;
          queue = Queue { from = M.receiver; to = call.callee };
        }
      | for call ∈ res.new_calls ] ·
      [ ResponseMessage {
          call_context = M.call_context;
          response = res.response;
        }
      | if res.response ≠ NoResponse ]

     // only if res.response ≠ NoResponse:
     call_contexts[M.call_context].replied = true
....

==== Message execution (trapping)

If a message traps, it gets dropped. No response is generated (some other message may still fulfill this calling context).

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    S.canisters[M.callee] ≠ EmptyCanister
    M.func(M.receiver, S.canisters[M.receiver].wasm_state) = Trap
....
State after::
....
S with messages = Older_messages · Younger_messages
....

==== Message execution (double response)

If a message tries to respond when its calling context has already be responded to, then we treat it like a trapping message.

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    S.canisters[M.callee] ≠ EmptyCanister
    M.func(M.receiver, S.canisters[M.receiver].wasm_state) = Return res
    S.call_contexts[M.call_context].replied = true
    res ≠ NoResponse
....
State after::
....
S with messages = Older_messages · Younger_messages
....

==== Call context starvation

If there is no call, downstream calling context or response that could possibly fulfill a calling context, then a reject is synthesized. The error message below is _not_ indicative. In particular, if the system has an idea about _why_ this starved, it can put that in there (e.g. the initial message handler trapped with an out-of-memory access).

Conditions::
....
    S.call_contexts[Ctxt_id].replied = false
    ∀ CallMessage msg ∈ S.messages. msg.call_context ≠ Ctxt_id
    ∀ ctxt_ids.
        (S.call_contexts[ctxt_ids].replied = false || S.response[ctxt_ids] exists)
        ==> S.call_contexts[ctxt_ids].caller.calling_context ≠ Ctxt_id
....
State after::
....
S with
    call_contexts[Ctxt_id].replied = true
    messages =
      S.messages ·
      ResponseMessage {
        call_context = Ctxt_id;
        response = Reject (CANISTER_ERROR, "starvation");
      }
....

==== Callback invocation

When an inter-canister call has been responded to, we can queue the call to the callback.

Conditions::
....
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    S.call_contexts[RM.call_context].origin =
      FromCanister {
        call_context = Ctxt_id2
        callback = F
      }
....
State after::
....
S with
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id2
        receiver = S.call_contexts[RM.call_context].canister
        func = F (RM.response)
        queue = Unordered
      } ·
      Younger_messages
....


==== Respond to user request

When an ingress method call has been responded to, we can record the response in the list of queries.

Conditions::
....
    S.requests[M] = Processing
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    S.call_contexts[RM.call_context].origin = FromUser { request = M }
....
State after::
....
S with
    messages = Older_messages · Younger_messages
    requests[M] =
      | Completed { result = R } if response = Reply R
      | Failed R                 if response = Reject R
....

==== Request expiry

At some point, a processed request can expire. Precise conditions are yet to be determined.

Conditions::
....
    (S.requests[M] = Completed _) or (S.requests[M] = Failed _)
....
State after::
....
S with
    requests[M] = (deleted)
....


==== Read: Status

The user can query the status of a request. The type of `result`, given as `Value` in the above spec, can vary depending on the request type.

NOTE: There is a phase where a request was issued by the client, but not accepted yet by the whole system. During this phase, the request status behaves as if the request has never been seen. It may silently be dropped, or eventually be marked as pending, as seen in the following rules.

Read request:: ReadStatus { request_id = MI }
Conditions::
....
   request_id_of(M) = MI
   S.requests[M] = MS
....
Read response::
A record with
* `{status: pending}` if `MS = Accepted` or `MS = Processing`
* `{status: rejected; reject_code: <code>: reject_message: <msg>}` if `MS = Failed (code, msg)`
* `{status: completed; result : <result>}` if `MS = Completed { result = result }`

==== Read: query call

Canister query calls can be executed directly.

Read request:: CanisterQuery Q
Conditions::
....
  S.canisters[Q.callee] ≠ EmptyCanister
  C = S.canisters[Q.callee]
  F = C.module.query_methods[Q.method_name]
....
Read response::
* If `F(Q.callee, Q.arg) = Trap` then
+
....
{status: failed; error: "Query execution trapped"}
....
* Else if `F(Q.callee, Q.arg) = Return (Reject (code, msg))` then
+
....
{status: rejected; reject_code: <code>: reject_message: <msg>}
....
* Else if `F(Q.callee, Q.arg) = Return (Reply R)` then
+
....
{status: success; result: <R> }
....


[#concrete-canisters]
=== Abstract Canisters to System API

In Section <<abstract-canisters>> we introduced an abstraction over the interface to a canister, to avoid cluttering the abstract specification of the Internet Computer from WebAssembly details. In this section, we will fill the gap and explain how the abstract canister interface maps to the <<system-api,concrete System API>> and the WebAssembly concepts as defined in the https://webassembly.github.io/spec/core/index.html[WebAssembly specification].

==== The concrete `WasmState`

The abstract `WasmState` maps to the WebAssembly _store_ `S`, which encompasses the functions, tables, memories and globals of the WebAssembly program.

As explained in Section “<<system-api-module>>”, the WebAssembly module imports at most _one_ memory and at most _one_ table; in the following, _the_ memory (resp. table) and the fields `mem` and `table` of `S` refer to that. Any system call that accesses the memory (resp. table) will trap if the module does not import the memory (resp. table).

We model `mem` as an array of bytes, and `table` as an array of execution functions.

==== The execution state

We can model the execution of WebAssembly functions as stateful functions that have access to the WebAssembly store. In order to also model the behavior of the system imports, which have access to additional data structures, we extend the state as follows:
....
Params = {
  arg : NoArg | Blob;
  reject_code : 0 | SYS_FATAL | SYS_TRANSIENT | …;
  reject_message : Text;
}
PartialCall = {
  callee : CanId;
  method : MethodName;
  arg : Blob;
  on_reply : StillMissing;
  on_reply_env : i32;
  on_reject : StillMissing;
  on_reject_env : i32;
  performed : Bool;
}
ExecutionState = {
  wasm_state : S; // a store as per WebAssembly spec
  api_nonce : (abstract)
  self_id : CanId;
  params : Params;
  response : NoResponse | Response;
  reply_params : { arg : Blob };
  calls : List PartialCall;
  performed_calls : List Call
}

....

This allows us to model WebAssembly functions, including host-provided imports, as functions with implicit mutable access to an `ExecutionState`, dubbed _execution functions_.
Syntactically, we express this using an implicit argument of type `ref ExecutionState` in angle brackets (e.g. `func<es>(api_nonce)` for the invocation of a WebAssembly function with type `+(api_nonce : anyref) -> ()+`).  The lifetime of the `ExecutionState` data structure, and the `api_nonce`, is that one invocation of such a function.

WARNING: It is nonsensical to pass to an execution function a `WasmState` that comes from a different WebAssembly module than one defining the function The current specification does not do that, because every canister gets instantiated exactly once. Once we add upgrading to this document this needs to be checked.

==== The concrete `CanisterModule`

Finally we can specify the abstract `CanisterModule` that models a concrete WebAssembly module.

* The `initial_wasm_state` mentioned below is the store of the WebAssembly module after _instantiation_ (as per WebAssembly spec) of the WasmModule contained in the <<canister-module-format,canister module>>, including executing a potential `(start)` function.

* For more convenience when creating a new `ExecutionState`, we define the following partial record:
+
....
empty_execution_state = {
  wasm_state = (undefined);
  api_nonce = (undefined);
  self_id = (undefined);
  params = (undefined);
  response = NoResponse;
  reply_params : { arg = "" };
  calls : [];
  performed_calls : [];
}
....


* The `init` field of the `CanisterModule` is defined as follows:
+
If the WebAssembly module does not export a function called under the name `canister_init`, then the argument blob is ignored and the `initial_wasm_state` is returned:
+
....
init = λ (self_id, blob) →
  Return initial_wasm_state
....
+
Otherwise, if the WebAssembly module exports a function `f` under the name `canister_init`, it is
+
....
init = λ (self_id, blob) →
  let es = ref {empty_execution_state with
      wasm_state = initial_wasm_state;
      api_nonce = fresh_nonce();
      self_id = self_id;
      params = { arg = blog; reject_code = 0; reject_message ""}
    }
  try func<es>(es.api_nonce) with Trap then Trap
  if es.performed_calls ≠ [] then Trap
  if es.response ≠ NoResponse then Trap
  Return es.wasm_state
....
+
This formulation checks afterwards that the system calls `call.perform` or `msg.reply` were not invoked; an implementation can of course trap already when these system calls are invoked.

* The partial map `update_methods` of the `CanisterModule` is defined for all method names `method` for which the WebAssembly program exports a function `f` named `canister_update <method>`, and has value
+
....
update_methods[method] = λ blob → λ (self_id, wasm_state) →
  let es = ref {empty_execution_state with
      wasm_state = wasm_state;
      api_nonce = fresh_nonce();
      self_id = self_id;
      params = { arg = blog; reject_code = 0; reject_message = "" }
    }
  try func<es>(es.api_nonce) with Trap then Trap
  Return {
    new_state = es.wasm_state;
    new_calls = es.performed_calls;
    response = es.response;
  }
....

* The partial map `query_methods` of the `CanisterModule` is defined for all method names `method` for which the WebAssembly program exports a function `f` named `canister_query <method>`, and has value
+
....
query_methods[method] = λ blob → λ (self_id, wasm_state) →
  let es = ref {empty_execution_state with
      wasm_state = wasm_state;
      api_nonce = fresh_nonce();
      self_id = self_id;
      params = { arg = blog; reject_code = 0; reject_message ""}
    }
  try func<es>(es.api_nonce) with Trap then Trap
  if es.performed_calls ≠ () then Trap
  if es.response = NoResponse then Trap
  Return es.response;
....
+
This formulation checks afterwards that the system calls `call.perform` was not invoked; an implementation can of course trap already when these system calls have been invoked.
+
By construction, the (possibly) modified `es.wasm_state` is discarded.


==== Host references

The System API defines various WebAssembly reference types (`api_nonce`, `canisterref`, `methodref`, `callref`), all passed as a WebAssembly `anyref`. These are opaque to the WebAssembly code, but transparent to our System API. So we model a value of type `anyref` as follows:
....
type anyref
  = APIRef (abstract)
  | CanisterRef CanId
  | MethodRef (CanId, MethodName)
  | CallRef Nat
....

The syntax `let MethodName (c, m) = ref else Trap` indicates that a system functions extracts the values `c` and `m` from a `methodref`, trapping if the reference is not actually a `methodref`. In the future, with the _type import_ WebAssembly proposal, module validation will ensure that these different variants of references are properly distinguished by type.

==== System imports

Upon _instantiation_ of the WebAssembly module, we can provide the following executions functions as imports.

....
msg.arg_data_size<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.params.arg = NoArg then Trap
  return |es.params.arg|

msg.arg_data_copy<es>(api_nonce : anyref, dst:i32, offset:i32, length:i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.params.arg = NoArg then Trap
  if offset+length > |es.params.arg| then Trap
  if dst+length > |es.wasm_state.mem| then Trap
  es.wasm_state.mem[dst..dst+length] := es.params.arg[offset..offset+length]

msg.reject_code<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  es.params.reject_code

msg.reject_msg_len<es>(api_nonce : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.reject_code = 0 then Trap
  return |es.params.reject_msg|

msg.reject_msg_copy<es>(api_nonce : anyref, dst:i32, offset:i32, length:i32) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.reject_code = 0 then Trap
  if offset+length > |es.params.reject_msg| then Trap
  if dst+length > |es.wasm_state.mem| then Trap
  es.wasm_state.mem[dst..dst+length] := es.params.reject_msg[offset..offset+length]

msg.reply_data_append<es>(api_nonce : anyref, src : i32, length : i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  if src+length > |es.wasm_state.mem| then Trap
  es.reply_params.arg := es.reply_params.arg · es.wasm_state.mem[src..src+len];

msg.reply<es>(api_nonce : anyref) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  es.response := Reply (es.reply_params.arg)

msg.reject<es>(api_nonce : anyref, src : i32, length : i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if es.response ≠ NoResponse then Trap
  if src+length > |es.wasm_state.mem| then Trap
  es.response := Reject (CANISTER_REJECT, es.wasm_state.mem[src..src+len])

canister.id_valid<es>(api_nonce : anyref, src : i32, len : i32) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if src+len > |es.wasm_state.mem| then Trap

  if is_valid_id(es.wasm_state.mem[src..src+len])
  then return 1
  then return 0

canister.id_lookup<es>(api_nonce : anyref, src : i32, len : i32) : anyref =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  if src+len > |es.wasm_state.mem| then Trap
  canister_id = es.wasm_state.mem[src..src+len]
  if not is_valid_id(canister_id) then Trap

  return (CanisterRef canister_id)

canister.id_len<es>(api_nonce : anyref, canister_ref : anyref) : i32 =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  let CanisterRef canister_id = canister_ref else Trap
  return |canister_id|

canister.id_copy<es>(api_nonce : anyref, canister_ref : anyref, dst: i32) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  let CanisterRef canister_id = canister_ref else Trap
  if dst+|canister_id| > |es.wasm_state.mem| then Trap
  es.wasm_state.mem[dst..dst+|canister_id| := canister_id

canister.self<es>(api_nonce : anyref) : anyref =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  return (CanisterRef es.self_id)

method.public<es>(
  api_nonce    : anyref,
  canister_ref : anyref,
  name_src     : i32,
  name_len     : i32,
) : ( anyref ) =
  if api_nonce ≠ APIRef es.api_nonce then Trap
  let CanisterRef callee = canister_ref else Trap
  if name_src+name_len > |es.wasm_state.mem| then Trap

  return (MethodRef callee es.wasm_state.mem[name_src..name_src+name_len])

call.create<es>(
  method_ref   : anyref,
) : ( anyref ) =
  let MethodRef callee method_name = method_ref else Trap

  callref := |es.calls|
  es.calls := es.calls ·
   {
      callee = callee;
      method_name = method_name;
      arg = "";
      on_reply = StillMissing;
      on_reply_env = 0;
      on_reject = StillMissing;
      on_reject_env = 0;
      performed = False;
    }
  return callref

call.arg_data_append<es>(callref : anyref, src : i32, len : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if src+len > |es.wasm_state.mem| then Trap

  es.calls[callidx].arg := es.calls[callidx].arg · es.wasm_state.mem[src..src+len];

call.on_reply<es>(callref : anyref, fun : i32, env : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if fun > |es.wasm_state.table| then Trap
  if typeof(es.wasm_state.table[fun]) ≠ func (anyref, i32) -> () then Trap
  if es.calls[callidx].on_reply ≠ StillMissing then Trap

  es.calls[callidx].on_reply := es.wasm_state.table[fun]
  es.calls[callidx].on_reply_env := env

call.on_reject<es>(callref : anyref, fun : i32, env : i32) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if fun > |es.wasm_state.table| then Trap
  if typeof(es.wasm_state.table[fun]) ≠ func (anyref, i32) -> () then Trap
  if es.calls[callidx].on_reject ≠ StillMissing then Trap

  es.calls[callidx].on_reject := es.wasm_state.table[fun]
  es.calls[callidx].on_reject_env := env

call.perform<es>(callref : anyref) =
  let CallRef callidx = callref else Trap
  if callidx >= |es.calls| then Trap
  if es.calls[callidx].performed then Trap
  if es.calls[callidx].on_reply = StillMissing then Trap
  if es.calls[callidx].on_reject = StillMissing then Trap

  es.calls[callidx].performed := True

  pc := es.calls[callidx]
  es.performed_calls := es.performed_calls ·
    {
      callee = pc.callee;
      method_name = pc.method_name;
      arg = pc.arg;
      callback = λ response → match response with
        Reply blob → mkWasmFunc
          ( { arg = blob; reject_code = 0 }
          , λ<es'>(api') → pc.on_reply<es'>(api', pc.onreply_env)
          )
        Reject (reject_code, _message) → mkWasmFunc
          ( { arg = NoArg; reject_code = reject_code }
          , λ<es>(api') → pc.on_reject<es'>(api, pc.onreject_env)
          )
    }

debug.print<es>(src : i32, len : i32) =
  return

debug.trap<es>(src : i32, len : i32) =
  Trap
....


== Discussion and comments

=== User and user key management

We have left it up to the state transition (admin) to assign UserId to public keys. In principle a UserId can be associated with several public keys. A public key on the other hand can map to at most one user. A simpler setting would be a bijection between keys and users, or even to have no user ids at all and just refer to public keys.

Currently the life cycle of a public key is existence or non-existence. A more fine-grained life cycle would be: pre-activation, active, suspended, revoked, deleted. Keys may also have usage constraints e.g. a user may want to have a not-so-secure key with a daily spending cap and very-secure key for high value transactions. And keys may come with activation/expiration times.

It is open whether UserId's are deleted if they have no associated public keys. If they are, there might be overlaps in UserId's over time. This could be avoided by guaranteeing a UserId is only used once, e.g., by incremental numbering (or something else to avoid races for special numbers) or using large random numbers.

As with keys, user ids and user accounts will also be subject to management. Their statuses can be: pre-activation, active, suspended, blacklisted, deleted. There may be usage constraints associated with them, and they may hold public information about a user, e.g., name.

In the future we want explicit interfaces over which a user registers a public key and manage their accounts. One could imagine the user creating an ingress message with new public key, optional existing user id, registration evidence (e.g. signature by existing public key or evidence of PKI certificate), user info (e.g. name or KYC), and signature on everything. Similarly, we would need methods for other types of key management and user management.

include::implementation-status.adoc[leveloffset=+1]
